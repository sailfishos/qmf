From 9a434a9d5232ed1b9056ff8ce897426cadc19497 Mon Sep 17 00:00:00 2001
From: Valerio Valerio <valerio.valerio@jollamobile.com>
Date: Wed, 29 May 2013 09:44:20 +0300
Subject: [PATCH] Accounts-qt integration.

---
 common.pri                                         |   34 +
 messagingframework.pro                             |   32 +-
 src/libraries/qmfclient/qmailaccountlistmodel.cpp  |   44 +-
 src/libraries/qmfclient/qmailstore.cpp             |    2 -
 src/libraries/qmfclient/qmailstore_p.cpp           | 1222 +++++++++++++++++++-
 src/libraries/qmfclient/qmailstore_p.h             |   47 +-
 src/libraries/qmfclient/qmfclient.pro              |   50 +-
 src/libraries/qmfclient/share/GenericEmail.service |   69 ++
 .../qmfclient/share/GenericProvider.provider       |   12 +
 src/libraries/qmfclient/ssoaccountmanager.cpp      |   66 ++
 src/libraries/qmfclient/ssoaccountmanager.h        |   75 ++
 src/libraries/qmfclient/ssoauthplugin.cpp          |  118 ++
 src/libraries/qmfclient/ssoauthplugin.h            |   74 ++
 src/libraries/qmfclient/ssosessionmanager.cpp      |  280 +++++
 src/libraries/qmfclient/ssosessionmanager.h        |   99 ++
 .../qmfmessageserver/qmailauthenticator.cpp        |    1 -
 .../messageservices/imap/imapauthenticator.cpp     |   29 +
 .../messageservices/imap/imapauthenticator.h       |    4 +
 src/plugins/messageservices/imap/imapclient.cpp    |  359 +++++-
 src/plugins/messageservices/imap/imapclient.h      |   28 +-
 src/plugins/messageservices/imap/imapprotocol.cpp  |   39 +-
 src/plugins/messageservices/imap/imapprotocol.h    |    4 +
 src/plugins/messageservices/imap/imapservice.cpp   |   68 +-
 .../messageservices/pop/popauthenticator.cpp       |   29 +-
 src/plugins/messageservices/pop/popauthenticator.h |    4 +
 src/plugins/messageservices/pop/popclient.cpp      |  125 +-
 src/plugins/messageservices/pop/popclient.h        |   25 +
 src/plugins/messageservices/pop/popservice.cpp     |   25 +
 src/plugins/messageservices/smtp/smtp.pro          |   18 +
 .../messageservices/smtp/smtpauthenticator.cpp     |   44 +-
 .../messageservices/smtp/smtpauthenticator.h       |    6 +-
 src/plugins/messageservices/smtp/smtpclient.cpp    |  162 ++-
 src/plugins/messageservices/smtp/smtpclient.h      |   28 +
 src/plugins/messageservices/smtp/smtpservice.cpp   |    5 +
 src/plugins/ssoauth/password/password.pro          |   27 +
 src/plugins/ssoauth/password/passwordplugin.cpp    |  177 +++
 src/plugins/ssoauth/password/passwordplugin.h      |   74 ++
 tests/tst_qmailstore/tst_qmailstore.cpp            |   11 +
 38 files changed, 3413 insertions(+), 103 deletions(-)
 create mode 100644 src/libraries/qmfclient/share/GenericEmail.service
 create mode 100644 src/libraries/qmfclient/share/GenericProvider.provider
 create mode 100644 src/libraries/qmfclient/ssoaccountmanager.cpp
 create mode 100644 src/libraries/qmfclient/ssoaccountmanager.h
 create mode 100644 src/libraries/qmfclient/ssoauthplugin.cpp
 create mode 100644 src/libraries/qmfclient/ssoauthplugin.h
 create mode 100644 src/libraries/qmfclient/ssosessionmanager.cpp
 create mode 100644 src/libraries/qmfclient/ssosessionmanager.h
 create mode 100644 src/plugins/ssoauth/password/password.pro
 create mode 100644 src/plugins/ssoauth/password/passwordplugin.cpp
 create mode 100644 src/plugins/ssoauth/password/passwordplugin.h

diff --git a/common.pri b/common.pri
index c690ce6..3b674a7 100644
--- a/common.pri
+++ b/common.pri
@@ -2,6 +2,40 @@ CONFIG(debug,debug|release) {
     DEFINES += QMF_ENABLE_LOGGING
 }
 
+equals(QT_MAJOR_VERSION, 4) {
+    packagesExist(accounts-qt) {
+        packagesExist(libsignon-qt) {
+            DEFINES += USE_ACCOUNTS_QT
+            CONFIG += link_pkgconfig
+            QT += xml
+            # accounts dependencies
+            PKGCONFIG += accounts-qt
+            # sso dependencies
+            PKGCONFIG += libsignon-qt
+        } else {
+            warning("Accounts-qt support requires libsignon-qt")
+        }
+    } else {
+         warning("Accounts-qt support requires accounts-qt")
+    }
+}
+equals(QT_MAJOR_VERSION, 5) {
+    packagesExist(accounts-qt5) {
+        packagesExist(libsignon-qt5) {
+            DEFINES += USE_ACCOUNTS_QT
+            CONFIG += link_pkgconfig
+            QT += xml
+            # accounts dependencies
+            PKGCONFIG += accounts-qt5
+            # sso dependencies
+            PKGCONFIG += libsignon-qt5
+        } else {
+            warning("Accounts-qt support requires libsignon-qt5")
+        }
+    } else {
+         warning("Accounts-qt support requires accounts-qt5")
+    }
+}
 
 win32 | macx {
 
diff --git a/messagingframework.pro b/messagingframework.pro
index d47d54d..9fecac0 100644
--- a/messagingframework.pro
+++ b/messagingframework.pro
@@ -12,22 +12,24 @@ SUBDIRS = src/libraries/qmfclient \
           tests
 
 !contains(DEFINES,QMF_NO_MESSAGE_SERVICE_EDITOR) {
-
-SUBDIRS += \
-          examples/qtmail/libs/qmfutil \
-          examples/qtmail/app \
-          examples/qtmail/plugins/viewers/generic \
-          examples/qtmail/plugins/composers/email \
-          examples/messagingaccounts \
-          examples/serverobserver
-          
-# disable benchmark test on mac until ported
-!macx {
-    !SERVER_AS_DLL {
-          SUBDIRS += benchmarks
+    SUBDIRS += \
+              examples/qtmail/libs/qmfutil \
+              examples/qtmail/app \
+              examples/qtmail/plugins/viewers/generic \
+              examples/qtmail/plugins/composers/email \
+              examples/messagingaccounts \
+              examples/serverobserver
+
+    # disable benchmark test on mac until ported
+    !macx {
+        !SERVER_AS_DLL {
+              SUBDIRS += benchmarks
+        }
     }
 }
 
+packagesExist(accounts-qt) | packagesExist(accounts-qt5) {
+    SUBDIRS += src/plugins/ssoauth/password
 }
 
 defineReplace(targetPath) {
@@ -41,8 +43,8 @@ dox.depends =
 
 QMAKE_EXTRA_TARGETS += dox
 
-include(doc/src/doc.pri)
-
 !unix {
      warning("IMAP COMPRESS capability is currently not supported on non unix platforms")
 }
+
+include(doc/src/doc.pri)
diff --git a/src/libraries/qmfclient/qmailaccountlistmodel.cpp b/src/libraries/qmfclient/qmailaccountlistmodel.cpp
index fa26c99..f9dd452 100644
--- a/src/libraries/qmfclient/qmailaccountlistmodel.cpp
+++ b/src/libraries/qmfclient/qmailaccountlistmodel.cpp
@@ -349,31 +349,37 @@ void QMailAccountListModel::accountsAdded(const QMailAccountIdList& ids)
     { 
         foreach(const QMailAccountId &id,results)
         {
-            LessThanFunctorA lessThan(d->sortKey);
+            if (!d->idList.contains(id)) {
+                LessThanFunctorA lessThan(d->sortKey);
 
-            //if sorting the list fails, then resort to a complete refresh
-            if(lessThan.invalidatedList())
-                fullRefresh();
-            else
-            {
-                QMailAccountIdList::iterator itr = d->lowerBound(id, lessThan);
-                int newIndex = (itr - d->idList.begin());
+                //if sorting the list fails, then resort to a complete refresh
+                if (lessThan.invalidatedList())
+                    fullRefresh();
+                else
+                {
+                    QMailAccountIdList::iterator itr = d->lowerBound(id, lessThan);
+                    int newIndex = (itr - d->idList.begin());
 
-                beginInsertRows(QModelIndex(),newIndex,newIndex);
-                d->idList.insert(itr, id);
+                    beginInsertRows(QModelIndex(),newIndex,newIndex);
+                    d->idList.insert(itr, id);
+                    endInsertRows();
+                }
+            } else {
+                qWarning() << "QMailAccountListModel: Account with the same id already present in the model";
+            }
+        }
+    } else {
+        foreach (const QMailAccountId &id,results) {
+            if (!d->idList.contains(id)) {
+                int index = d->idList.count();
+                beginInsertRows(QModelIndex(),index,(index + results.count() - 1));
+                d->idList.append(id);
                 endInsertRows();
+            } else {
+                qWarning() << "QMailAccountListModel: Account with the same id already present in the model";
             }
         }
     }
-    else
-    {
-        int index = d->idList.count();
-
-        beginInsertRows(QModelIndex(),index,(index + results.count() - 1));
-        foreach(const QMailAccountId &id,results)
-            d->idList.append(id);
-        endInsertRows();
-    }
     d->needSynchronize = false;
 }
 
diff --git a/src/libraries/qmfclient/qmailstore.cpp b/src/libraries/qmfclient/qmailstore.cpp
index 1dd382b..258968c 100644
--- a/src/libraries/qmfclient/qmailstore.cpp
+++ b/src/libraries/qmfclient/qmailstore.cpp
@@ -546,7 +546,6 @@ bool QMailStore::updateAccount(QMailAccount* account, QMailAccountConfiguration
     d->setLastError(NoError);
     if (!d->updateAccount(account, config, &updatedAccounts))
         return false;
-
     emitAccountNotification(Updated, updatedAccounts);
     return true;
 }
@@ -564,7 +563,6 @@ bool QMailStore::updateAccountConfiguration(QMailAccountConfiguration *config)
     d->setLastError(NoError);
     if (!d->updateAccountConfiguration(config, &updatedAccounts))
         return false;
-
     emitAccountNotification(Updated, updatedAccounts);
     return true;
 }
diff --git a/src/libraries/qmfclient/qmailstore_p.cpp b/src/libraries/qmfclient/qmailstore_p.cpp
index dbea2c4..29d5b51 100644
--- a/src/libraries/qmfclient/qmailstore_p.cpp
+++ b/src/libraries/qmfclient/qmailstore_p.cpp
@@ -54,6 +54,10 @@
 #include <QSqlRecord>
 #include <QTextCodec>
 
+#ifdef USE_ACCOUNTS_QT
+#include <QSharedPointer>
+#endif
+
 #if defined(Q_OS_LINUX)
 #include <malloc.h>
 #endif
@@ -1772,7 +1776,15 @@ QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAcc
         bool noCase((a.property == QMailAccountKey::Name) || (a.property == QMailAccountKey::FromAddress));
 
         QString expression = columnExpression(columnName, a.op, a.valueList, patternMatching, bitwise, noCase);
-        
+#ifdef USE_ACCOUNTS_QT
+        Q_UNUSED (store);
+        // Only ID could be queried here,
+        // All other properties will be queried
+        // from Accounts subsystem
+        Q_ASSERT(a.property == QMailAccountKey::Id);
+        q << expression;
+#else
+
         switch(a.property)
         {
         case QMailAccountKey::Id:
@@ -1812,14 +1824,18 @@ QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAcc
         case QMailAccountKey::LastSynchronized:
             q << expression;
             break;
-        }
+        }  
+#endif
     }
     return item;
 }
 
 template<>
-QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMessageKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
+QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &key, const QMailMessageKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
 {
+#ifndef USE_ACCOUNTS_QT
+    Q_UNUSED(key);
+#endif
     QString item;
     {
         QTextStream q(&item);
@@ -1904,10 +1920,20 @@ QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMes
         case QMailMessageKey::ParentAccountId:
             if(a.valueList.first().canConvert<QMailAccountKey>()) {
                 QMailAccountKey parentAccountKey = a.valueList.first().value<QMailAccountKey>();
+#ifdef USE_ACCOUNTS_QT
+                QMailAccountIdList parentAccountIdList = store.searchSSOAccounts(parentAccountKey);
+
+                // Rewrite argument and execute builder again
+                QMailMessageKey::ArgumentType &arg = const_cast<QMailMessageKey::ArgumentType&>(a);
+                arg = QMailMessageKey::parentAccountId(parentAccountIdList, QMailDataComparator::Includes).arguments().first();
+                return whereClauseItem(key, arg, alias, field, store);
+#else
+
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
                 q << store.buildWhereClause(QMailStorePrivate::Key(parentAccountKey, nestedAlias)) << ")";
+#endif
             } else {
                 q << expression;
             }
@@ -1985,8 +2011,11 @@ QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMes
 }
 
 template<>
-QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolderKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
+QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &key, const QMailFolderKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
 {
+#ifndef USE_ACCOUNTS_QT
+    Q_UNUSED(key);
+#endif
     QString item;
     {
         QTextStream q(&item);
@@ -2024,7 +2053,7 @@ QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolde
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailfolders " << nestedAlias;
-                q << store.buildWhereClause(QMailStorePrivate::Key(folderSubKey, nestedAlias)) << ")";
+                q << store.buildWhereClause(QMailStorePrivate::Key(folderSubKey, nestedAlias)) << ")";                
             } else {
                 q << expression;
             }
@@ -2051,10 +2080,19 @@ QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolde
         case QMailFolderKey::ParentAccountId:
             if(a.valueList.first().canConvert<QMailAccountKey>()) {
                 QMailAccountKey accountSubKey = a.valueList.first().value<QMailAccountKey>();
+#ifdef USE_ACCOUNTS_QT
+                QMailAccountIdList acountIdList = store.searchSSOAccounts(accountSubKey);
+
+                // Rewrite argument and execute builder again
+                QMailFolderKey::ArgumentType &arg = const_cast<QMailFolderKey::ArgumentType&>(a);
+                arg = QMailFolderKey::parentAccountId(acountIdList, QMailDataComparator::Includes).arguments().first();
+                return whereClauseItem(key, arg, alias, field, store);
+#else
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
                 q << store.buildWhereClause(QMailStorePrivate::Key(accountSubKey, nestedAlias)) << ")";
+#endif
             } else {
                 q << expression;
             }
@@ -2236,6 +2274,434 @@ QMailContentManager::DurabilityRequirement durability(bool commitOnSuccess)
 {
     return (commitOnSuccess ? QMailContentManager::EnsureDurability : QMailContentManager::DeferDurability);
 }
+#ifdef USE_ACCOUNTS_QT
+// Forward declaration
+bool SSOAccountSatisfyTheKey(Accounts::Account* ssoAccount, const QMailAccountKey& key);
+
+template <typename Property>
+bool SSOAccountCompareProperty(Accounts::Account* ssoAccount, Property value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        if (!arguments.front().canConvert<Property>()) {
+            if (arguments.front().canConvert<QMailAccountKey>()) {
+                QMailAccountKey accountKey = arguments.front().value<QMailAccountKey>();
+                return SSOAccountSatisfyTheKey(ssoAccount, accountKey);
+            }
+
+            qMailLog(Messaging) << "Failed to convert argument";
+            return false;
+        }
+
+        Property argument = arguments.front().value<Property>();
+        switch (op) {
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            default:
+                qMailLog(Messaging) << "This comparator is not supported";
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+        switch (op) {
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (argument.canConvert<Property>() && argument.value<Property>() == value)
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (argument.canConvert<Property>() && argument.value<Property>() == value)
+                        return false;
+                }
+                return true;
+
+
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+            default:
+                qMailLog(Messaging) << "This comparator is not supported";
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+
+    Q_ASSERT(false);
+    return false;
+}
+
+template <>
+bool SSOAccountCompareProperty(Accounts::Account*, quint64 value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        bool ok = false;
+        quint64 argument = arguments.front().toULongLong(&ok);
+        if (!ok) {
+            qMailLog(Messaging) << "Failed to convert to quing64";
+            return false;
+        }
+
+        switch (op) {
+            case QMailKey::LessThan:
+                return value < argument;
+
+            case QMailKey::LessThanEqual:
+                return value <= argument;
+
+            case QMailKey::GreaterThan:
+                return value > argument;
+
+            case QMailKey::GreaterThanEqual:
+                return value >= argument;
+
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                return ((value & argument) == argument);
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                return !(value & argument);
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+
+        switch (op) {
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+                // This comparator is not supported for multiple integer arguments
+                Q_ASSERT(false);
+                break;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toULongLong())
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toULongLong())
+                        return false;
+                }
+                return true;
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+    Q_ASSERT(false);
+    return false;
+}
+
+template <>
+bool SSOAccountCompareProperty(Accounts::Account*, const QString& value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        if (!arguments.front().canConvert<QString>()) {
+            qMailLog(Messaging) << "Failed to convert to string";
+            return false;
+        }
+
+        QString argument = arguments.front().toString();
+        switch (op) {
+            case QMailKey::LessThan:
+                return value < argument;
+
+            case QMailKey::LessThanEqual:
+                return value <= argument;
+
+            case QMailKey::GreaterThan:
+                return value > argument;
+
+            case QMailKey::GreaterThanEqual:
+                return value >= argument;
+
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                return value.contains(argument);
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                return !value.contains(argument);
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+
+        switch (op) {
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+                // This comparator is not supported for multiple integer arguments
+                Q_ASSERT(false);
+                break;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toString())
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toString())
+                        return false;
+                }
+                return true;
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+    Q_ASSERT(false);
+    return false;
+}
+
+bool SSOAccountCompareProperty(Accounts::Account* ssoAccount, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count() == 1);
+
+    QStringList argument = arguments.front().toStringList();
+
+    QString key   = argument.front();
+    QString value = argument.count() == 2 ? argument.back() : QString();
+
+    ssoAccount->beginGroup("customFields");
+
+    bool result = false;
+    switch (op) {
+        case QMailKey::LessThan:
+        case QMailKey::LessThanEqual:
+        case QMailKey::GreaterThan:
+        case QMailKey::GreaterThanEqual:
+            // This comparator is not supported for custom fields
+            Q_ASSERT(false);
+            break;
+
+        case QMailKey::Equal:
+            result = ssoAccount->contains(key) && (ssoAccount->valueAsString(key) == value);
+            break;
+
+        case QMailKey::NotEqual:
+            result = !ssoAccount->contains(key) || (ssoAccount->valueAsString(key) != value);
+            break;
+
+        case QMailKey::Includes:
+        case QMailKey::Present:
+            result = ssoAccount->contains(key) &&  ssoAccount->valueAsString(key).contains(value);
+            break;
+
+        case QMailKey::Excludes:
+        case QMailKey::Absent:
+            result = !(ssoAccount->contains(key) && ssoAccount->valueAsString(key).contains(value));
+            break;
+
+        default:
+            Q_ASSERT(false);
+            break;
+    }
+    ssoAccount->endGroup();
+    return result;
+}
+
+bool SSOAccountSatisfyTheProperty(Accounts::Account* ssoAccount, const QMailAccountKey::ArgumentType& argument)
+{
+    Q_ASSERT(ssoAccount);
+
+    switch (argument.property) {
+        case QMailAccountKey::Id:
+            return SSOAccountCompareProperty<QMailAccountId>(ssoAccount, QMailAccountId(ssoAccount->id()), argument.op, argument.valueList);
+
+        case QMailAccountKey::Name:
+            return SSOAccountCompareProperty<const QString&>(ssoAccount, ssoAccount->displayName(), argument.op, argument.valueList);
+
+        case QMailAccountKey::MessageType:
+            return SSOAccountCompareProperty<quint64>(ssoAccount, ssoAccount->valueAsInt("type"), argument.op, argument.valueList);
+
+        case QMailAccountKey::FromAddress:
+            return SSOAccountCompareProperty<const QString&>(ssoAccount, QMailAddress(ssoAccount->valueAsString("emailaddress")).address(), argument.op, argument.valueList);
+
+        case QMailAccountKey::Status: {
+            Accounts::Service service = ssoAccount->selectedService();
+
+            ssoAccount->selectService();
+            const bool& enabled = ssoAccount->enabled();
+            ssoAccount->selectService(service);
+
+            quint64 status = ssoAccount->valueAsUInt64("status");
+            status &= (~QMailAccount::Enabled);
+            status |= enabled?(QMailAccount::Enabled):0;
+
+            return SSOAccountCompareProperty<quint64>(ssoAccount,
+                                                      status,
+                                                      argument.op, argument.valueList);
+        }
+
+        case QMailAccountKey::Custom:
+            return SSOAccountCompareProperty(ssoAccount, argument.op, argument.valueList);
+
+        default:
+            Q_ASSERT(false);
+            break;
+    }
+    return false;
+}
+
+bool SSOAccountSatisfyTheKey(Accounts::Account* ssoAccount, const QMailAccountKey& key)
+{
+    Q_ASSERT(ssoAccount);
+
+    if (key.isNonMatching())
+        return false;
+
+    if (key.isEmpty())
+        return true;
+
+    // In case of it is not compound key and has got a list of arguments
+    // follow the list of arguments and compare
+    if (!key.arguments().isEmpty()) {
+        typedef QList<QMailAccountKey::ArgumentType> ListOfArguments;
+        ListOfArguments::const_iterator it = key.arguments().begin();
+
+        bool result = SSOAccountSatisfyTheProperty(ssoAccount, *it);
+        while (++it != key.arguments().end()) {
+            switch (key.combiner()) {
+                case QMailKey::And:
+                    result = result && SSOAccountSatisfyTheProperty(ssoAccount, *it);
+                    break;
+                case QMailKey::Or:
+                    result = result || SSOAccountSatisfyTheProperty(ssoAccount, *it);
+                    break;
+                default:
+                    Q_ASSERT(false);
+                    break;
+            }
+        }
+
+        // Return negated value if key was negeated
+        return key.isNegated() ? !result : result;
+    }
+
+    // In case of compound key, process each subkey separatelly
+    if (!key.subKeys().isEmpty()) {
+        typedef QList<QMailAccountKey> ListOfKeys;
+        ListOfKeys::const_iterator it = key.subKeys().begin();
+
+        bool result = SSOAccountSatisfyTheKey(ssoAccount, *it);
+        while (++it != key.subKeys().end()) {
+            switch (key.combiner()) {
+                case QMailKey::And:
+                    result = result && SSOAccountSatisfyTheKey(ssoAccount, *it);
+                    break;
+                case QMailKey::Or:
+                    result = result || SSOAccountSatisfyTheKey(ssoAccount, *it);
+                    break;
+                default:
+                    Q_ASSERT(false);
+                    break;
+            }
+        }
+
+        // Return negated value if key was negeated
+        return key.isNegated() ? !result : result;
+    }
+
+    // This key is not empty and has neither subkeys nor arguments.
+    Q_ASSERT(false);
+    return false;
+}
+
+void SSOHandleError(const Accounts::Error& error)
+{
+    switch (error.type()) {
+    case Accounts::Error::NoError:
+        break;
+    case Accounts::Error::Deleted:
+    case Accounts::Error::AccountNotFound:
+        qWarning() << "Accounts:" << error.message();
+        break;
+    case Accounts::Error::Unknown:
+    case Accounts::Error::Database:
+    case Accounts::Error::DatabaseLocked:
+        qCritical() << "Accounts:" << error.message();
+        Q_ASSERT (false);
+        break;
+    default:
+        Q_ASSERT (false);
+    }
+}
+#endif
 
 } // namespace
 
@@ -2471,7 +2937,36 @@ QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
         contentMutex = new ProcessMutex(databaseIdentifier(), 3);
     }
     connect(&databaseUnloadTimer, SIGNAL(timeout()), this, SLOT(unloadDatabase()));
+#ifdef USE_ACCOUNTS_QT
+    // manager to notify QMailStore about the changes
+    connect(manager, SIGNAL(accountCreated(Accounts::AccountId)), this, SLOT(accountCreated(Accounts::AccountId)));
+    connect(manager, SIGNAL(accountRemoved(Accounts::AccountId)), this, SLOT(accountRemoved(Accounts::AccountId)));
+    connect(manager, SIGNAL(accountUpdated(Accounts::AccountId)), this, SLOT(accountUpdated(Accounts::AccountId)));
+#endif
+}
+
+#ifdef USE_ACCOUNTS_QT
+QSharedPointer<Accounts::Account> QMailStorePrivate::getEmailAccount(const Accounts::AccountId id)
+{
+    //get account from the manager
+    QSharedPointer<Accounts::Account> ssoAccount(manager->account(id));
+
+    if (!ssoAccount) {
+        qWarning() << Q_FUNC_INFO << "Account with was not found" ;
+        SSOHandleError(manager->lastError());
+        return ssoAccount;
+    }
+
+    // check if it is an e-mail account
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    if (!services.count()) {
+        qWarning() << Q_FUNC_INFO << "E-mail Services not found, make sure that *.service and *.provider files are properly installed and e-mail services are enabled.";
+        ssoAccount = QSharedPointer<Accounts::Account>();
+    }
+
+    return ssoAccount;
 }
+#endif
 
 QMailStorePrivate::~QMailStorePrivate()
 {
@@ -2676,6 +3171,23 @@ void QMailStorePrivate::clearContent()
 
     Transaction t(this);
 
+#ifdef USE_ACCOUNTS_QT
+    // Remove all SSO email accounts
+    Accounts::AccountIdList accountIDList = manager->accountList("e-mail");
+
+    // Populate all E-Mail accounts
+    foreach (Accounts::AccountId accountID, accountIDList) {
+        // Remove account
+        QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(accountID);
+
+        if (ssoAccount) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+        } else
+            SSOHandleError(manager->lastError());
+    }
+#endif
+
     // Drop all data
     foreach (const QString &table, database()->tables()) {
         if (table != "versioninfo" && table != "mailstatusflags") {
@@ -2997,10 +3509,18 @@ bool QMailStorePrivate::idValueExists(quint64 id, const QString& table)
     return (query.first());
 }
 
+#ifdef USE_ACCOUNTS_QT
+bool QMailStorePrivate::idExists(const QMailAccountId& id)
+{
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    return (ssoAccount != NULL);
+}
+#else
 bool QMailStorePrivate::idExists(const QMailAccountId& id, const QString& table)
 {
     return idValueExists(id.toULongLong(), (table.isEmpty() ? "mailaccounts" : table));
 }
+#endif
 
 bool QMailStorePrivate::idExists(const QMailFolderId& id, const QString& table)
 {
@@ -3029,6 +3549,44 @@ bool QMailStorePrivate::messageExists(const QString &serveruid, const QMailAccou
     return query.first();
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailAccount QMailStorePrivate::extractAccount(const QSharedPointer<Accounts::Account>& ssoAccount)
+{
+    Q_ASSERT(ssoAccount);
+
+    QMailAccount result;
+    result.setId(QMailAccountId(ssoAccount->id()));
+    QString name = ssoAccount->valueAsString("email/email_box_name");
+    if (name.isEmpty())
+        name = ssoAccount->displayName();
+    result.setName(name);
+    result.setMessageType(static_cast<QMailMessageMetaDataFwd::MessageType>(ssoAccount->valueAsInt("type")));
+    result.setStatus(ssoAccount->valueAsUInt64("status"));
+
+    Accounts::Service service = ssoAccount->selectedService();
+
+    ssoAccount->selectService();
+    const bool& enabled = ssoAccount->enabled();
+    ssoAccount->selectService(service);
+    const bool& isDefault = ssoAccount->valueAsBool("email/default");
+
+    result.setStatus(QMailAccount::Enabled, enabled);
+    result.setStatus(QMailAccount::PreferredSender, isDefault);
+
+    result.setSignature(ssoAccount->valueAsString("signature"));
+    result.setFromAddress(ssoAccount->contains("fullName")?
+                          QMailAddress(ssoAccount->valueAsString("fullName"),ssoAccount->valueAsString("emailaddress")):
+                          QMailAddress(ssoAccount->valueAsString("emailaddress")));
+
+    if ((static_cast<uint>(ssoAccount->valueAsUInt64("lastSynchronized"))) == 0) {
+            result.setLastSynchronized(QMailTimeStamp());
+    }
+    else {
+        result.setLastSynchronized(QMailTimeStamp(QDateTime::fromTime_t(static_cast<uint>(ssoAccount->valueAsUInt64("lastSynchronized")))));
+    }
+    return result;
+}
+#else
 QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
 {
     const AccountRecord record(r);
@@ -3044,7 +3602,7 @@ QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
 
     return result;
 }
-
+#endif
 
 QMailThread QMailStorePrivate::extractThread(const QSqlRecord& r)
 {
@@ -3287,8 +3845,12 @@ QString QMailStorePrivate::buildOrderClause(const Key& key) const
         const QMailThreadSortKey &sortKey(key.key<QMailThreadSortKey>());
         return ::buildOrderClause(sortKey.arguments(), key.alias());
     } else if (key.isType<QMailAccountSortKey>()) {
+#ifdef USE_ACCOUNTS_QT
+        Q_ASSERT(false);
+#else
         const QMailAccountSortKey &sortKey(key.key<QMailAccountSortKey>());
         return ::buildOrderClause(sortKey.arguments(), key.alias());
+#endif
     } 
 
     return QString();
@@ -5355,21 +5917,246 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::updateCustomFields(quint64 i
     return Success;
 }
 
-QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::addAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString>& fields)
 {
-    QString sql("SELECT name,value FROM %1 WHERE id=?");
-    QSqlQuery query(simpleQuery(sql.arg(tableName),
-                                QVariantList() << id,
-                                QString("%1 custom field query").arg(tableName)));
-    if (query.lastError().type() != QSqlError::NoError)
-        return DatabaseFailure;
+    if (!fields.isEmpty()) {
+        ssoAccount->beginGroup("customFields");
 
-    while (query.next())
-        fields->insert(query.value(0).toString(), query.value(1).toString());
+        // Insert any custom fields belonging to this account
+        QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+        for ( ; it != end; ++it) {
+            ssoAccount->setValue(it.key(), QVariant(it.value()));
+        }
+        ssoAccount->endGroup();
+
+        if (!ssoAccount->syncAndBlock())
+            return DatabaseFailure;
+    }
 
     return Success;
 }
 
+QMailStorePrivate::AttemptResult QMailStorePrivate::updateAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields)
+{
+    ssoAccount->beginGroup("customFields");
+
+    QMap<QString, QString> existing;
+    {
+        foreach (const QString& name, ssoAccount->allKeys()) {
+             existing.insert(name, ssoAccount->valueAsString(name));
+        }
+    }
+
+    QVariantList obsoleteFields;
+    QVariantList modifiedFields;
+    QVariantList modifiedValues;
+    QVariantList addedFields;
+    QVariantList addedValues;
+
+    // Compare the sets
+    QMap<QString, QString>::const_iterator fend = fields.end(), eend = existing.end();
+    QMap<QString, QString>::const_iterator it = existing.begin();
+    for ( ; it != eend; ++it) {
+        QMap<QString, QString>::const_iterator current = fields.find(it.key());
+        if (current == fend) {
+            obsoleteFields.append(QVariant(it.key()));
+        } else if (*current != *it) {
+            modifiedFields.append(QVariant(current.key()));
+            modifiedValues.append(QVariant(current.value()));
+        }
+    }
+
+    for (it = fields.begin(); it != fend; ++it) {
+        if (existing.find(it.key()) == eend) {
+            addedFields.append(QVariant(it.key()));
+            addedValues.append(QVariant(it.value()));
+        }
+    }
+
+    if (!obsoleteFields.isEmpty()) {
+        // Remove the obsolete fields
+        foreach (const QVariant& obsolet, obsoleteFields) {
+            ssoAccount->remove(obsolet.toString());
+        }
+    }
+
+    if (!modifiedFields.isEmpty()) {
+        // Batch update of the modified fields
+        QVariantList::const_iterator field = modifiedFields.begin();
+        QVariantList::const_iterator value = modifiedValues.begin();
+        while (field != modifiedFields.end() && value != modifiedValues.end())
+            ssoAccount->setValue(field++->toString(), *value++);
+    }
+
+    if (!addedFields.isEmpty()) {
+        // Batch insert of the added fields
+        QVariantList::const_iterator field = addedFields.begin();
+        QVariantList::const_iterator value = addedValues.begin();
+        while (field != addedFields.end() && value != addedValues.end())
+            ssoAccount->setValue(field++->toString(), *value++);
+
+    }
+
+    ssoAccount->endGroup();
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::accountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, QMap<QString, QString>* fields)
+{
+    ssoAccount->beginGroup("customFields");
+    foreach (const QString& key, ssoAccount->allKeys()) {
+        qMailLog(Messaging) << "Custom Field:" << key << "=" << ssoAccount->valueAsString(key);
+        fields->insert(key, ssoAccount->valueAsString(key));
+    }
+    ssoAccount->endGroup();
+
+    return Success;
+}
+#endif
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
+{
+    QString sql("SELECT name,value FROM %1 WHERE id=?");
+    QSqlQuery query(simpleQuery(sql.arg(tableName),
+                                QVariantList() << id,
+                                QString("%1 custom field query").arg(tableName)));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        fields->insert(query.value(0).toString(), query.value(1).toString());
+
+    return Success;
+}
+
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                                                                      QMailAccountIdList *addedAccountIds,
+                                                                      Transaction &t, bool commitOnSuccess)
+{
+    if (account->id().isValid() && idExists(account->id())) {
+        qWarning() << "Account already exists in database, use update instead";
+        return Failure;
+    }
+
+    // Create new account in Accounts subsystem
+    QSharedPointer<Accounts::Account> ssoAccount(manager->createAccount("GenericProvider"));
+    if (!ssoAccount) {
+        SSOHandleError(manager->lastError());
+        qMailLog(Messaging) << "Failed to create account";
+        return DatabaseFailure;
+    }
+
+    ssoAccount->setDisplayName(account->name());
+    ssoAccount->setEnabled(account->status() & QMailAccount::Enabled);
+
+    Accounts::ServiceList services = ssoAccount->services("e-mail");
+    if (!services.count()) {
+        qMailLog(Messaging) << "E-mail Services not found, make sure that *.service and *.provider files are properly installed.";
+        return DatabaseFailure;
+    }
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+    Q_ASSERT(service.serviceType() == "e-mail");
+
+    ssoAccount->selectService(service);
+    ssoAccount->setEnabled(true); // service is enabled anyway
+    ssoAccount->setValue("type", static_cast<int>(account->messageType()));
+    ssoAccount->setValue("status", account->status());
+    ssoAccount->setValue("signature", account->signature());
+    ssoAccount->setValue("emailaddress", account->fromAddress().address());
+    ssoAccount->setValue("fullName", account->fromAddress().name());
+    //Account was never synced
+    ssoAccount->setValue("lastSynchronized", quint64(0));
+
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+
+    //Extract the insert id
+    QMailAccountId insertId = QMailAccountId(ssoAccount->id());
+
+    {
+        // Insert any standard folders configured for this account
+        const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
+        if (!folders.isEmpty()) {
+            QVariantList types;
+            QVariantList folderIds;
+
+            QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator it = folders.begin(), end = folders.end();
+            for ( ; it != end; ++it) {
+                types.append(static_cast<int>(it.key()));
+                folderIds.append(it.value().toULongLong());
+            }
+
+            // Batch insert the folders
+            QString sql("INSERT into mailaccountfolders (id,foldertype,folderid) VALUES (%1,?,?)");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(insertId.toULongLong())),
+                                       QVariantList() << QVariant(types)
+                                       << QVariant(folderIds),
+                                       "addAccount mailaccountfolders query"));
+            if (query.lastError().type() != QSqlError::NoError) {
+                ssoAccount->remove();
+                ssoAccount->syncAndBlock();
+                return DatabaseFailure;
+            }
+        }
+
+        // Insert any custom fields belonging to this account
+        AttemptResult result = addAccountCustomFields(ssoAccount, account->customFields());
+        if (result != Success) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+            return result;
+        }
+    }
+
+    if (config) {
+        foreach (const QString &service, config->services()) {
+            QMailAccountConfiguration::ServiceConfiguration &serviceConfig(config->serviceConfiguration(service));
+            const QMap<QString, QString> &fields = serviceConfig.values();
+            QString serviceName = serviceConfig.service();
+
+            // Open configuration group
+            ssoAccount->beginGroup(serviceName);
+
+            // Insert any configuration fields belonging to this account
+            QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+            for ( ; it != end; ++it) {
+                ssoAccount->setValue(it.key(), QVariant(it.value()));
+            }
+            // Close group of keys
+            ssoAccount->endGroup();
+        }
+
+        // Save all changes
+        if (!ssoAccount->syncAndBlock()) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+            return DatabaseFailure;
+        }
+
+        config->setId(insertId);
+    }
+
+    account->setId(insertId);
+
+    if (commitOnSuccess && !t.commit()) {
+        qWarning() << "Could not commit account changes to database";
+
+        account->setId(QMailAccountId()); //revert the id
+        ssoAccount->remove();
+        ssoAccount->syncAndBlock();
+        return DatabaseFailure;
+    }
+
+    addedAccountIds->append(insertId);
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
                                                                       QMailAccountIdList *addedAccountIds, 
                                                                       Transaction &t, bool commitOnSuccess)
@@ -5470,6 +6257,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccou
     addedAccountIds->append(insertId);
     return Success;
 }
+#endif
 
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddFolder(QMailFolder *folder, 
                                                                      QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
@@ -6043,7 +6831,50 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
     if (!id.isValid())
         return Failure;
 
+#ifdef USE_ACCOUNTS_QT
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    if (!ssoAccount)
+      return Failure;
+
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.isValid());
+    Q_ASSERT(service.serviceType() == "e-mail");
+#endif
+
     if (account) {
+#ifdef USE_ACCOUNTS_QT
+        ssoAccount->selectService(service);
+        bool isEmailBoxName = false;
+        if(!ssoAccount->valueAsString("email/email_box_name").isEmpty()) {
+            isEmailBoxName = true;
+            ssoAccount->setValue("email/email_box_name",account->name());
+        }
+        ssoAccount->selectService();
+        if (isEmailBoxName) {
+            ssoAccount->setDisplayName(ssoAccount->valueAsString("username"));
+        }
+        else {
+            ssoAccount->setDisplayName(account->name());
+        }
+        ssoAccount->setEnabled(account->status() & QMailAccount::Enabled);
+        ssoAccount->selectService(service);
+        ssoAccount->setValue("type", static_cast<int>(account->messageType()));
+        ssoAccount->setValue("status", account->status());
+        ssoAccount->setValue("signature", account->signature());
+        ssoAccount->setValue("emailaddress", account->fromAddress().address());
+        ssoAccount->setValue("fullName", account->fromAddress().name());
+        if (account->lastSynchronized().isValid()) {
+            ssoAccount->setValue("lastSynchronized", static_cast<quint64>(account->lastSynchronized().toLocalTime().toTime_t()));
+        }
+        else {
+            ssoAccount->setValue("lastSynchronized", quint64(0));
+        }
+        bool isDefault = account->status() & QMailAccount::PreferredSender;
+        ssoAccount->setValue("email/default", isDefault);
+#else
         QString properties("type=?, name=?, emailaddress=?, status=?, signature=?, lastsynchronized=?");
         QVariantList propertyValues;
         propertyValues << static_cast<int>(account->messageType()) 
@@ -6060,7 +6891,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             if (query.lastError().type() != QSqlError::NoError)
                 return DatabaseFailure;
         }
-
+#endif
         // Update any standard folders configured
         const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
         QMap<QMailFolder::StandardFolder, QMailFolderId> existingFolders;
@@ -6135,13 +6966,20 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         }
 
         if (account->customFieldsModified()) {
+#ifdef USE_ACCOUNTS_QT
+            AttemptResult result = updateAccountCustomFields(ssoAccount, account->customFields());
+#else
             AttemptResult result = updateCustomFields(id.toULongLong(), account->customFields(), "mailaccountcustom");
+#endif
             if (result != Success)
                 return result;
         }
     }
 
     if (config) {
+#ifdef USE_ACCOUNTS_QT
+        ssoAccount->selectService(service);
+#endif
         // Find the complete set of configuration fields
         QMap<QPair<QString, QString>, QString> fields;
 
@@ -6159,6 +6997,17 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         QMap<QPair<QString, QString>, QString> existing;
 
         {
+#ifdef USE_ACCOUNTS_QT
+            foreach (const QString& group, ssoAccount->childGroups()) {
+                if (group != "customFields") {
+                    ssoAccount->beginGroup(group);
+                    foreach (const QString& name, ssoAccount->allKeys()) {
+                         existing.insert(qMakePair(group, name), ssoAccount->valueAsString(name));
+                    }
+                    ssoAccount->endGroup();
+                }
+            }
+#else
             QSqlQuery query(simpleQuery("SELECT service,name,value FROM mailaccountconfig WHERE id=?",
                                         QVariantList() << id.toULongLong(),
                                         "updateAccount mailaccountconfig select query"));
@@ -6167,6 +7016,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
 
             while (query.next())
                 existing.insert(qMakePair(query.value(0).toString(), query.value(1).toString()), query.value(2).toString());
+#endif
         }
 
         QMap<QString, QVariantList> obsoleteFields;
@@ -6203,13 +7053,20 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             for ( ; it != end; ++it) {
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                ssoAccount->beginGroup(service);
+                foreach (const QVariant& field, fields) {
+                    ssoAccount->remove(field.toString());
+                }
+                ssoAccount->endGroup();
+#else
                 QString sql("DELETE FROM mailaccountconfig WHERE id=? AND service='%1' AND name IN %2");
                 QSqlQuery query(simpleQuery(sql.arg(service).arg(expandValueList(fields)),
                                             QVariantList() << id.toULongLong() << fields,
                                             "updateAccount mailaccountconfig delete query"));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
 
@@ -6220,13 +7077,23 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
                 const QVariantList &values = vit.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                QVariantList::const_iterator field = fields.begin();
+                QVariantList::const_iterator value = values.begin();
+
+                ssoAccount->beginGroup(service);
+                while (field != fields.end() && value != values.end())
+                    ssoAccount->setValue(field++->toString(), *value++);
+
+                ssoAccount->endGroup();
+#else
                 QString sql("UPDATE mailaccountconfig SET value=? WHERE id=%1 AND service='%2' AND name=?");
                 QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
                                            QVariantList() << QVariant(values) << QVariant(fields),
                                            "updateAccount mailaccountconfig update query"));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
 
@@ -6237,13 +7104,23 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
                 const QVariantList &values = vit.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                QVariantList::const_iterator field = fields.begin();
+                QVariantList::const_iterator value = values.begin();
+
+                ssoAccount->beginGroup(service);
+                while (field != fields.end() && value != values.end())
+                    ssoAccount->setValue(field++->toString(), *value++);
+
+                ssoAccount->endGroup();
+#else
                 QString sql("INSERT INTO mailaccountconfig (id,service,name,value) VALUES (%1,'%2',?,?)");
                 QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
                                            QVariantList() << QVariant(fields) << QVariant(values),
                                            "updateAccount mailaccountconfig insert query"));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
     }
@@ -6252,7 +7129,12 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         qWarning() << "Could not commit account update to database";
         return DatabaseFailure;
     }
-        
+
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+#endif
+
     if (account) {
         // Update the account cache
         if (accountCache.contains(id))
@@ -7233,6 +8115,10 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptEnsureDurability(Tran
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const QMailAccountKey &key, int *result, 
                                                                          ReadLock &)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList accountIDList = searchSSOAccounts(key);
+    *result =  accountIDList.count();
+#else
     QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM mailaccounts",
                                 Key(key),
                                 "countAccounts mailaccounts query"));
@@ -7241,7 +8127,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const Q
 
     if (query.first())
         *result = extractValue<int>(query.value(0));
-
+#endif
     return Success;
 }
 
@@ -7312,6 +8198,14 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const Q
                                                                          QMailAccountIdList *ids, 
                                                                          ReadLock &)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList accountIDList = searchSSOAccounts(key, sortKey);
+
+    if (limit)
+        *ids << accountIDList.mid(offset, limit);
+    else
+        *ids << accountIDList.mid(offset, -1);
+#else
     QSqlQuery query(simpleQuery("SELECT id FROM mailaccounts",
                                 QVariantList(),
                                 QList<Key>() << Key(key) << Key(sortKey),
@@ -7322,7 +8216,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const Q
 
     while (query.next())
         ids->append(QMailAccountId(extractValue<quint64>(query.value(0))));
-
+#endif
     return Success;
 }
 
@@ -7386,6 +8280,71 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryMessages(const Q
     return Success;
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id,
+                                                                   QMailAccount *result,
+                                                                   ReadLock &)
+{
+    if (!id.isValid())
+        return Failure;
+
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    if (!ssoAccount) {
+        return Failure;
+    }
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.serviceType() == "e-mail");
+
+    ssoAccount->selectService(service);
+
+    *result = extractAccount(ssoAccount);
+    Q_ASSERT(result->id() == id);
+
+    {
+        // Find any standard folders configured for this account
+        QSqlQuery query(simpleQuery("SELECT foldertype,folderid FROM mailaccountfolders WHERE id=?",
+                                    QVariantList() << id.toULongLong(),
+                                    "account mailaccountfolders query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next())
+            result->setStandardFolder(QMailFolder::StandardFolder(query.value(0).toInt()), QMailFolderId(query.value(1).toULongLong()));
+    }
+
+    // Find any custom fields for this SSO account
+    QMap<QString, QString> fields;
+    AttemptResult attemptResult = accountCustomFields(ssoAccount, &fields);
+    if (attemptResult != Success)
+        return attemptResult;
+
+    result->setCustomFields(fields);
+    result->setCustomFieldsModified(false);
+
+    // Find the type of the account
+    foreach (const QString& group, ssoAccount->childGroups()) {
+        if (group != "customFields") {
+            ssoAccount->beginGroup(group);
+
+            QString serviceType = ssoAccount->valueAsString("servicetype");
+            if (serviceType.contains("source"))
+                result->addMessageSource(group);
+
+            if (serviceType.contains("sink"))
+                result->addMessageSink(group);
+
+            ssoAccount->endGroup();
+        }
+    }
+
+    //update cache
+    accountCache.insert(*result);
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id, 
                                                                    QMailAccount *result, 
                                                                    ReadLock &)
@@ -7452,7 +8411,50 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAc
 
     return Failure;
 }
+#endif
+
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id,
+                                                                                QMailAccountConfiguration *result,
+                                                                                ReadLock &)
+{
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+
+    if (!ssoAccount)
+        return Failure;
+
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.serviceType() == "e-mail");
+    ssoAccount->selectService(service);
+
+    foreach (const QString& group, ssoAccount->childGroups()) {
+        if (group != "customFields") {
+            if (!result->services().contains(group)) {
+                // Add this service to the configuration
+                result->addServiceConfiguration(group);
+            }
+
+            QMailAccountConfiguration::ServiceConfiguration* serviceConfig = &result->serviceConfiguration(group);
+            Q_ASSERT(serviceConfig);
+
+            ssoAccount->beginGroup(group);
+            foreach (const QString& key, ssoAccount->allKeys()) {
+                serviceConfig->setValue(key,ssoAccount->valueAsString(key));
+            }
+            ssoAccount->endGroup();
+        }
+    }
+
+    result->setId(id);
+    result->setModified(false);
 
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id, 
                                                                                 QMailAccountConfiguration *result, 
                                                                                 ReadLock &)
@@ -7502,6 +8504,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(
 
     return Success;
 }
+#endif
 
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptThread(const QMailThreadId &id, QMailThread *result, ReadLock &)
 {
@@ -8619,11 +9622,26 @@ bool QMailStorePrivate::checkPreconditions(const QMailFolder& folder, bool updat
 
     if(folder.parentAccountId().isValid())
     {
-        if(!idExists(folder.parentAccountId(),"mailaccounts"))
-        {
+#ifdef USE_ACCOUNTS_QT
+
+        Accounts::AccountId accountId = folder.parentAccountId().toULongLong();
+        QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(accountId);
+
+        if (!ssoAccount) {
+          qWarning() << "Parent account does not exist!";
+          return false;
+        }
+
+        if (!ssoAccount->supportsService("e-mail")) {
+          qMailLog(Messaging) << "Parent account does not support e-mail service!";
+          return false;
+        }
+#else
+        if(!idExists(folder.parentAccountId(),"mailaccounts")) {
             qWarning() << "Parent account does not exist!";
             return false;
         }
+#endif
     }
 
     return true;
@@ -9148,6 +10166,14 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
                                        QMailThreadIdList& modifiedThreadIds,
                                        QMailAccountIdList& modifiedAccountIds)
 {
+#ifdef USE_ACCOUNTS_QT
+    // Searching across all accounts inside SSO
+    deletedAccountIds << searchSSOAccounts(key);
+
+    // No accounts? Then we're already done
+    if (deletedAccountIds.isEmpty())
+        return true;
+#else
     {
         // Get the identifiers for all the accounts we're deleting
         QSqlQuery query(simpleQuery("SELECT t0.id FROM mailaccounts t0",
@@ -9167,6 +10193,7 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         if (noAccounts)
             return true;
     }
+#endif
 
     // We won't create new message removal records, since there will be no account to link them to
     QMailStore::MessageRemovalOption option(QMailStore::NoRemovalRecord);
@@ -9211,7 +10238,22 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         // Delete all threads contained by the account we're deleting
         if (!deleteThreads(threadKey, option, deletedThreadIds, deletedMessageIds, expiredContent, updatedMessageIds, modifiedFolderIds, modifiedThreadIds, modifiedAccountIds))
             return false;
+#ifdef USE_ACCOUNTS_QT
+    {
+        // Remove accounts from SSO
+        foreach (const QMailAccountId& accountID, deletedAccountIds) {
+
+            QSharedPointer<Accounts::Account> ssoAccount(manager->account(accountID.toULongLong()));
 
+            if (ssoAccount) {
+                ssoAccount->remove();
+                if (!ssoAccount->syncAndBlock())
+                    return false;
+            } else
+                SSOHandleError(manager->lastError());
+        }
+    }
+#else
     {
         // Remove any custom fields associated with these accounts
         QSqlQuery query(simpleQuery("DELETE FROM mailaccountcustom",
@@ -9238,7 +10280,7 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         if (query.lastError().type() != QSqlError::NoError)
             return false;
     }
-
+#endif
     // Do not report any deleted entities as updated
     for (QMailMessageIdList::iterator mit = updatedMessageIds.begin(); mit != updatedMessageIds.end(); ) {
         if (deletedMessageIds.contains(*mit)) {
@@ -9597,3 +10639,133 @@ void QMailStorePrivate::emitIpcNotification(const QMailMessageIdList& ids, quint
     q_ptr->messagesUpdated(ids);
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailAccountIdList QMailStorePrivate::searchSSOAccounts(const QMailAccountKey& key, const QMailAccountSortKey& sortKey) const
+{
+    Q_UNUSED (sortKey);
+
+    Accounts::AccountIdList accountIDList = manager->accountList("e-mail");
+
+    // Populate all E-Mail accounts
+    typedef QList<Accounts::Account*> AccountList;
+    QMailAccountIdList accountList;
+
+    foreach (const Accounts::AccountId& accountID, accountIDList) {
+        Accounts::Account* ssoAccount = manager->account(accountID);
+        if (!ssoAccount) {
+            SSOHandleError(manager->lastError());
+            continue;
+        }
+
+        Accounts::ServiceList services = ssoAccount->enabledServices();
+        const int &count = services.count();
+        switch (count) {
+        case 0: // ignore such accounts
+            break;
+        case 1: {
+            Accounts::Service service = services.first();
+            ssoAccount->selectService(service);
+            if (SSOAccountSatisfyTheKey(ssoAccount, key))
+                accountList.append(QMailAccountId(ssoAccount->id()));
+            } break;
+        default:
+            qCritical() << Q_FUNC_INFO << "Account must contain one enabled email service. Got" << count
+                        << "for account" << accountID;
+            Q_ASSERT (false);
+            return QMailAccountIdList();
+        }
+
+        delete ssoAccount;
+    }
+
+    /*
+     * TBD: Use sortKey to sort found accounts properly
+     */
+
+    return accountList;
+}
+
+void QMailStorePrivate::accountCreated(Accounts::AccountId id)
+{
+    // ignore non-email accounts
+    if (!accountValid(id))
+        return;
+
+    QMailAccountIdList ids;
+    ids << QMailAccountId(id);
+    Q_Q(QMailStore);
+
+    ENFORCE(QMetaObject::invokeMethod(q, "accountsAdded", Qt::QueuedConnection, Q_ARG(QMailAccountIdList, ids)));
+}
+
+void QMailStorePrivate::accountRemoved(Accounts::AccountId id)
+{
+    // ignore non-email accounts
+    if (!accountValid(id))
+        return;
+
+    const QMailAccountId& qId = QMailAccountId(id);
+    ENFORCE(QMetaObject::invokeMethod(this, "onAccountRemovedFinished", Qt::QueuedConnection, Q_ARG(QMailAccountId, qId)));
+}
+
+void QMailStorePrivate::onAccountRemovedFinished(const QMailAccountId &id)
+{
+    Q_Q (QMailStore);
+    emit q->accountsRemoved(QMailAccountIdList() << id);
+    // remove from cache after the notification, so that it is possible to
+    // know details of the removed account
+    accountCache.remove(id);
+}
+
+void QMailStorePrivate::accountUpdated(Accounts::AccountId id)
+{
+    if (!accountValid(id))
+        return;
+
+    const QMailAccountId& qId = QMailAccountId(id);
+    accountCache.remove(qId);
+    Q_Q(QMailStore);
+    ENFORCE(QMetaObject::invokeMethod(q, "accountsUpdated", Qt::QueuedConnection, Q_ARG(QMailAccountIdList, QMailAccountIdList() << qId)));
+}
+
+bool QMailStorePrivate::accountValid(Accounts::AccountId id) const
+{
+    QSharedPointer<Accounts::Account> account(manager->account(id));
+
+    if (!account) {
+        SSOHandleError(manager->lastError());
+        return false;
+    }
+
+    // Account should already have the type "e-mail",
+    // ignore extra checks
+
+
+    return true;
+}
+
+void QMailStorePrivate::disconnectIpc()
+{
+    QMailStoreImplementation::disconnectIpc();
+
+    ipcLastDbUpdated = QMail::lastDbUpdated();
+}
+
+void QMailStorePrivate::reconnectIpc()
+{
+    QMailStoreImplementation::reconnectIpc();
+
+    // clear cache if needed
+    const QDateTime& lastDbUpdated = QMail::lastDbUpdated();
+    if (ipcLastDbUpdated != lastDbUpdated) {
+        // Clear all caches
+        accountCache.clear();
+        folderCache.clear();
+        messageCache.clear();
+        uidCache.clear();
+        threadCache.clear();
+
+        ipcLastDbUpdated = lastDbUpdated;
+    }
+}
+#endif
diff --git a/src/libraries/qmfclient/qmailstore_p.h b/src/libraries/qmfclient/qmailstore_p.h
index a372583..953df5a 100644
--- a/src/libraries/qmfclient/qmailstore_p.h
+++ b/src/libraries/qmfclient/qmailstore_p.h
@@ -58,6 +58,11 @@
 #include <QCache>
 #include <QTimer>
 
+#ifdef USE_ACCOUNTS_QT
+#include <Accounts/account.h>
+#include "ssoaccountmanager.h"
+#endif
+
 //#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
 //#define QMAILSTORE_USE_RTTI //define if RTTI is available to assist debugging
 
@@ -247,6 +252,11 @@ public:
     static ValueType extractValue(const QVariant& var, const ValueType &defaultValue = ValueType());
 
     enum AttemptResult { Success = 0, Failure, DatabaseFailure };
+
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList searchSSOAccounts(const QMailAccountKey& key, const QMailAccountSortKey& sortKey = QMailAccountSortKey()) const;
+#endif
+
 public slots:
     void unloadDatabase();
     
@@ -340,8 +350,11 @@ private:
     QSqlQuery batchQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor);
 
     bool idValueExists(quint64 id, const QString& table);
-
+#ifdef USE_ACCOUNTS_QT
+    bool idExists(const QMailAccountId& id);
+#else
     bool idExists(const QMailAccountId& id, const QString& table = QString());
+#endif
     bool idExists(const QMailFolderId& id, const QString& table = QString());
     bool idExists(const QMailMessageId& id, const QString& table = QString());
 
@@ -417,6 +430,12 @@ private:
     AttemptResult updateLatestInConversation(quint64 threadId, QMailMessageIdList *messagesUpdated, quint64 *updatedTo = 0);
     AttemptResult updateLatestInConversation(const QSet<quint64> &threadIds, QMailMessageIdList *messagesUpdated);
 
+#ifdef USE_ACCOUNTS_QT
+    AttemptResult addAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields);
+    AttemptResult updateAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields);
+    AttemptResult accountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, QMap<QString, QString>* fields);
+#endif
+
     AttemptResult addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
     AttemptResult updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
     AttemptResult customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName);
@@ -714,7 +733,11 @@ private:
 
     AttemptResult registerSubject(const QString &baseSubject, quint64 messageId, const QMailMessageId &predecessorId, bool missingAncestor);
 
+#ifdef USE_ACCOUNTS_QT
+    QMailAccount extractAccount(const QSharedPointer<Accounts::Account>& ssoAccount);
+#else
     QMailAccount extractAccount(const QSqlRecord& r);
+#endif
     QMailThread extractThread(const QSqlRecord &r);
     QMailFolder extractFolder(const QSqlRecord& r);
     QMailMessageMetaData extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties = allMessageProperties());
@@ -753,10 +776,29 @@ private:
 
     static void extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties, QMailMessageMetaData* metaData);
 
+#ifdef USE_ACCOUNTS_QT
+    bool accountValid(Accounts::AccountId id) const;
+
+        virtual void disconnectIpc();
+        virtual void reconnectIpc();
+
+    private Q_SLOTS:
+
+        void accountCreated(Accounts::AccountId id);
+        void accountRemoved(Accounts::AccountId id);
+        void accountUpdated(Accounts::AccountId id);
+        void onAccountRemovedFinished(const QMailAccountId& id);
+#endif
+
 private:
     Q_DECLARE_PUBLIC (QMailStore)
     QMailStore * const q_ptr;
 
+#ifdef USE_ACCOUNTS_QT
+    SSOAccountManager manager;
+    QSharedPointer<Accounts::Account> getEmailAccount(const Accounts::AccountId id);
+#endif
+
     template <typename T, typename KeyType> 
     class Cache
     {
@@ -811,6 +853,9 @@ private:
     static ProcessMutex *contentMutex;
 
     int globalLocks;
+#ifdef USE_ACCOUNTS_QT
+    QDateTime ipcLastDbUpdated;
+#endif
 };
 
 template <typename ValueType>
diff --git a/src/libraries/qmfclient/qmfclient.pro b/src/libraries/qmfclient/qmfclient.pro
index 39c34bb..949e8ef 100644
--- a/src/libraries/qmfclient/qmfclient.pro
+++ b/src/libraries/qmfclient/qmfclient.pro
@@ -95,7 +95,6 @@ PRIVATE_HEADERS += bind_p.h \
 
 HEADERS += $$PUBLIC_HEADERS $$PRIVATE_HEADERS
 
-
 SOURCES += longstream.cpp \
            longstring.cpp \
            qmailaccount.cpp \
@@ -171,17 +170,35 @@ TRANSLATIONS += libqtopiamail-ar.ts \
                 libqtopiamail-zh_CN.ts \
                 libqtopiamail-zh_TW.ts
 
-equals(QT_MAJOR_VERSION, 4): header_files.path=$$QMF_INSTALL_ROOT/include/qmfclient
-equals(QT_MAJOR_VERSION, 5): header_files.path=$$QMF_INSTALL_ROOT/include/qmfclient5
-header_files.files=$$PUBLIC_HEADERS
+packagesExist(accounts-qt) | packagesExist(accounts-qt5) {
+    PRIVATE_HEADERS += \
+               ssoaccountmanager.h
 
-INSTALLS += header_files
+    PUBLIC_HEADERS += \
+               ssosessionmanager.h \
+               ssoauthplugin.h
 
-unix: {
-	CONFIG += create_pc create_prl
-	QMAKE_PKGCONFIG_LIBDIR  = $$target.path
-	QMAKE_PKGCONFIG_INCDIR  = $$header_files.path
-	QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+    # For Qtc
+    HEADERS += ssoaccountmanager.h \
+               ssosessionmanager.h \
+               ssoauthplugin.h
+
+    SOURCES += ssoaccountmanager.cpp \
+               ssosessionmanager.cpp \
+               ssoauthplugin.cpp
+
+    # THIS NEEDS TO BE CHECKED
+    # Install generic SSO provider description
+    sso_providers.files = share/GenericProvider.provider
+    sso_providers.path  = $$QMF_INSTALL_ROOT/share/accounts/providers
+
+    # Install generic SSO service description
+    sso_services.files = share/GenericEmail.service
+    sso_services.path  = $$QMF_INSTALL_ROOT/share/accounts/services
+
+    INSTALLS += sso_providers sso_services
+} else {
+     warning("Accounts-qt support requires accounts-qt")
 }
 
 packagesExist(icu-uc) {
@@ -194,4 +211,17 @@ packagesExist(icu-uc) {
     warning("icu not available, not doing character set detection")
 }
 
+equals(QT_MAJOR_VERSION, 4): header_files.path=$$QMF_INSTALL_ROOT/include/qmfclient
+equals(QT_MAJOR_VERSION, 5): header_files.path=$$QMF_INSTALL_ROOT/include/qmfclient5
+header_files.files=$$PUBLIC_HEADERS
+
+unix: {
+        CONFIG += create_pc create_prl
+        QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+        QMAKE_PKGCONFIG_INCDIR  = $$header_files.path
+        QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+}
+
+INSTALLS += header_files
+
 include(../../../common.pri)
diff --git a/src/libraries/qmfclient/share/GenericEmail.service b/src/libraries/qmfclient/share/GenericEmail.service
new file mode 100644
index 0000000..d3c9bde
--- /dev/null
+++ b/src/libraries/qmfclient/share/GenericEmail.service
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<service id="GenericEmail">
+  <type>e-mail</type>
+  <name>Other mail account</name>
+  <icon>generic_email</icon>
+  <provider>GenericProvider</provider>
+
+  <!-- default settings (account settings have precedence over these) -->
+  <template>
+    <setting name="type" type="i">0</setting>
+    <setting name="name">Generic Email Account</setting>
+    <setting name="status" type="i">0</setting>
+    <setting name="signature"></setting>
+    <setting name="emailaddress"></setting>
+    <setting name="enabled" type="b">false</setting>
+    <group name="auth">
+            <setting name="method">password</setting>
+            <setting name="mechanism">password</setting>
+    </group>
+    <!-- Exclude default configuration
+    <pop3>
+      <setting name="server">pop3.example.com</setting>
+      <setting name="port" type="i">143</setting>
+      <setting name="encryption" type="b">0</setting>
+      <setting name="canDelete" type="b">0</setting>
+      <setting name="autoDownload" type="b">0</setting>
+      <setting name="maxSize" type="i">102400</setting>
+      <setting name="checkInterval" type="i">-1</setting>
+      <setting name="intervalCheckRoamingEnabled" type="i">0</setting>
+    </pop3>
+    <imap4>
+       <setting name="server">imap.example.com</setting>
+       <setting name="port" type="i">110</setting>
+       <setting name="encryption" type="b">0</setting>
+       <setting name="canDelete" type="b">0</setting>
+       <setting name="autoDownload" type="b">0</setting>
+       <setting name="maxSize" type="i">102400</setting>
+       <setting name="pushEnabled" type="b">0</setting>
+       <setting name="baseFolder"></setting>
+       <setting name="draftsFolder"></setting>
+       <setting name="trashFolder"></setting>
+       <setting name="junkFolder"></setting>
+       <setting name="checkInterval" type="i">-1</setting>
+       <setting name="intervalCheckRoamingEnabled" type="b">0</setting>
+    </imap4>
+    <smtp>
+       <setting name="address">email@example.com</setting>
+       <setting name="server">smtp.example.com</setting>
+       <setting name="port" type="i">25</setting>
+       <setting name="authentication" type="b">0</setting>
+       <setting name="encryption" type="b">0</setting>
+     </smtp>
+     -->
+  </template>
+
+  <!-- preview account -->
+  <preview>
+    <parameters>
+      <setting name="server">talkdemo.google.com</setting>
+      <setting name="account">googledemo@gmail.com</setting>
+      <setting name="password">demo</setting>
+    </parameters>
+    <setting name="display_name">GTalk demo</setting>
+  </preview>
+
+  <!-- type-specific data -->
+  <type_data>
+  </type_data>
+</service>
diff --git a/src/libraries/qmfclient/share/GenericProvider.provider b/src/libraries/qmfclient/share/GenericProvider.provider
new file mode 100644
index 0000000..bf9c746
--- /dev/null
+++ b/src/libraries/qmfclient/share/GenericProvider.provider
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<provider id="GenericProvider">
+  <name>Other mail account</name>
+  <icon>generic_provider</icon>
+
+  <template>
+    <group name="auth">
+      <setting name="method">password</setting>
+      <setting name="mechanism">password</setting>
+    </group>
+  </template>
+</provider>
diff --git a/src/libraries/qmfclient/ssoaccountmanager.cpp b/src/libraries/qmfclient/ssoaccountmanager.cpp
new file mode 100644
index 0000000..6cbf216
--- /dev/null
+++ b/src/libraries/qmfclient/ssoaccountmanager.cpp
@@ -0,0 +1,66 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "ssoaccountmanager.h"
+
+using namespace Accounts;
+
+Manager* SSOAccountManager::_manager = 0;
+int SSOAccountManager::_refCount = 0;
+
+SSOAccountManager::SSOAccountManager()
+{
+    if (!_manager) {
+        Q_ASSERT(!_refCount);
+        _manager = new Manager("e-mail");
+        _manager->setAbortOnTimeout(true);
+    }
+
+    ++_refCount;
+}
+
+SSOAccountManager::~SSOAccountManager()
+{
+    if (--_refCount == 0) {
+        delete _manager;
+        _manager = 0;
+    }
+}
diff --git a/src/libraries/qmfclient/ssoaccountmanager.h b/src/libraries/qmfclient/ssoaccountmanager.h
new file mode 100644
index 0000000..aa75682
--- /dev/null
+++ b/src/libraries/qmfclient/ssoaccountmanager.h
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SSOACCOUNTMANAGER_H
+#define SSOACCOUNTMANAGER_H
+
+#include <qglobal.h>
+#include "qmailglobal.h"
+
+// Accounts
+#include <Accounts/Manager>
+
+/// Accounts::Manager wrapper.
+class QMF_EXPORT SSOAccountManager
+{
+public:
+    SSOAccountManager();
+    ~SSOAccountManager();
+
+    Accounts::Manager* operator ->() const
+    {
+        Q_ASSERT (_manager);
+        return _manager;
+    }
+
+    operator Accounts::Manager*() const
+    {
+        Q_ASSERT (_manager);
+        return _manager;
+    }
+
+private:
+    Q_DISABLE_COPY (SSOAccountManager);
+    static Accounts::Manager* _manager;
+    static int _refCount;
+};
+#endif // SSOACCOUNTMANAGER_H
diff --git a/src/libraries/qmfclient/ssoauthplugin.cpp b/src/libraries/qmfclient/ssoauthplugin.cpp
new file mode 100644
index 0000000..e085e2d
--- /dev/null
+++ b/src/libraries/qmfclient/ssoauthplugin.cpp
@@ -0,0 +1,118 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valrio Valrio <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "ssoauthplugin.h"
+
+#include <QMap>
+#include <QDebug>
+#include <qmailpluginmanager.h>
+
+#define PLUGIN_KEY "ssoauth"
+
+typedef QMap<QString, SSOAuthService*> PluginMap;
+
+// Load all the auth plugins into a map for quicker reference
+static PluginMap initMap(QMailPluginManager& manager)
+{
+    PluginMap map;
+
+    foreach (const QString &item, manager.list()) {
+        QObject *instance = manager.instance(item);
+        if (SSOAuthService* iface = qobject_cast<SSOAuthService*>(instance))
+                map.insert(iface->key(), iface);
+    }
+    return map;
+}
+
+// Return a reference to a map containing all loaded plugin objects
+static PluginMap& pluginMap()
+{
+    static QMailPluginManager pluginManager(PLUGIN_KEY);
+    static PluginMap map(initMap(pluginManager));
+
+    return map;
+}
+
+// Return the auth plugin object matching the specified ID
+static SSOAuthService* mapping(const QString& key)
+{
+    PluginMap::ConstIterator it;
+    if ((it = pluginMap().find(key)) != pluginMap().end())
+        return it.value();
+
+    qWarning() << "Failed attempt to map plugin: " << key;
+    return 0;
+}
+
+SSOAuthService::SSOAuthService(QObject *parent)
+    : QObject(parent)
+{
+}
+
+SSOAuthService::~SSOAuthService()
+{
+}
+
+/*!
+    Returns a list of the keys of the installed plugins.
+ */
+QStringList SSOAuthFactory::keys()
+{
+    QStringList in;
+
+    foreach (PluginMap::mapped_type plugin, pluginMap())
+        in << plugin->key();
+
+    return in;
+}
+
+/*!
+    Creates a plugin object of the class identified by \a key.
+*/
+SSOAuthService* SSOAuthFactory::createService(const QString& key)
+{
+    if (SSOAuthService* plugin = mapping(key))
+        return plugin->createService();
+
+    return 0;
+}
+
+
diff --git a/src/libraries/qmfclient/ssoauthplugin.h b/src/libraries/qmfclient/ssoauthplugin.h
new file mode 100644
index 0000000..42fd3ec
--- /dev/null
+++ b/src/libraries/qmfclient/ssoauthplugin.h
@@ -0,0 +1,74 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valrio Valrio <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SSOAUTHPLUGIN_H
+#define SSOAUTHPLUGIN_H
+
+#include "qmailglobal.h"
+#include <QObject>
+#include <QString>
+#include <QVariantMap>
+#include <SignOn/SessionData>
+
+class QMF_EXPORT SSOAuthService : public QObject
+{
+    Q_OBJECT
+
+public:
+    SSOAuthService(QObject* parent = 0);
+    ~SSOAuthService();
+
+    virtual QString key() const = 0;
+    virtual QList<QByteArray> authentication(const SignOn::SessionData &sessionData,
+                                         const QString &serviceType, const QString &userName, int serviceAuthentication) const = 0;
+    virtual SignOn::SessionData sessionData(const QString &accountProvider, QVariantMap authParameters,
+                                            bool setUiPolicy) const = 0;
+    virtual SSOAuthService *createService() = 0;
+};
+
+class QMF_EXPORT SSOAuthFactory
+{
+public:
+    static QStringList keys();
+    static SSOAuthService *createService(const QString& key);
+};
+
+#endif // SSOAUTHPLUGIN_H
diff --git a/src/libraries/qmfclient/ssosessionmanager.cpp b/src/libraries/qmfclient/ssosessionmanager.cpp
new file mode 100644
index 0000000..a543d56
--- /dev/null
+++ b/src/libraries/qmfclient/ssosessionmanager.cpp
@@ -0,0 +1,280 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valrio Valrio <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "ssosessionmanager.h"
+#include "ssoaccountmanager.h"
+#include <qmaillog.h>
+
+#include <Accounts/AccountService>
+#include <Accounts/AuthData>
+
+/*!
+    \class SSOSessionManager
+
+    \preliminary
+    \brief The SSOSessionManager class provides a manager to query authentication details
+    from accounts-sso framework.
+    \ingroup messaginglibrary
+*/
+
+/*!
+    \fn ssoSessionError(const QString &error)
+
+    This signal is emitted when we receive a reply to an authentication
+    request from accounts-sso framework and a error occurred, the error
+    details are described by \a error.
+
+    \sa ssoSessionResponse()
+*/
+
+/*!
+    \fn ssoSessionResponse(const QList<QByteArray> &ssoLogin)
+
+    This signal is emitted when we receive a reply to a authentication
+    request from accounts-sso framework, the authentication details are
+    described by \a ssologin.
+
+    \sa ssoSessionError()
+*/
+
+SSOSessionManager::SSOSessionManager(QObject *parent)
+    : QObject(parent),
+      _waitForSso(false),
+      _identity(0),
+      _session(0)
+{
+    _availableAuthMethods = SSOAuthFactory::keys();
+}
+
+SSOSessionManager::~SSOSessionManager()
+{
+}
+
+bool SSOSessionManager::authPluginAvailable(const QString &method) const
+{
+    return _availableAuthMethods.contains(method);
+}
+
+/*!
+    Cancels the current session.
+*/
+
+void SSOSessionManager::cancel()
+{
+    if (_waitForSso) {
+        _session->cancel();
+        // Canceled by other process,
+        // no need to emit any error from here.
+        _waitForSso = false;
+    }
+}
+
+/*!
+    Creates a new SSO identity for the account identified by \a id for
+    the service to \a serviceType with the authentication type \a serviceAuthentication.
+
+    Returns true if the account has one email service enabled and a valid identity stored
+    in ths accounts-sso database, otherwise returns false.
+
+    The authentication details will be queried from accounts-sso framework and reported by
+    ssoSessionResponse() signal, if a error occurs it will be reported by ssoSessionError()
+    signal.
+
+    \sa ssoSessionResponse(), ssoSessionError()
+*/
+
+bool SSOSessionManager::createSsoIdentity(const QMailAccountId &id, const QString &serviceType,
+                                          int serviceAuthentication)
+{
+    deleteSsoIdentity();
+    _serviceAuthentication = serviceAuthentication;
+    _serviceType = serviceType;
+
+    SSOAccountManager manager;
+    Accounts::Account* account = manager->account(static_cast<Accounts::AccountId>(id.toULongLong()));
+    if (!account)
+        return false;
+
+    Accounts::ServiceList emailServices = account->enabledServices();
+    if (1 != emailServices.count()) {
+        qMailLog(Messaging) << Q_FUNC_INFO << "Account must have one active e-mail service, but it has "
+                       << emailServices.count();
+        return false;
+    }
+
+    account->selectService(emailServices.first());
+    Accounts::AccountService* emailService = new Accounts::AccountService(account, account->selectedService());
+    Accounts::AuthData auth = emailService->authData();
+    _accountProvider = account->providerName();
+    _authMethod = auth.method();
+    _authMechanism = auth.mechanism();
+    _authParameters = auth.parameters();
+
+    if (!authPluginAvailable(_authMethod)) {
+        qMailLog(Messaging) << Q_FUNC_INFO
+                            << "SSO error: No authentication plugin found for the following method: " + _authMethod;
+        return false;
+    }
+
+    quint32 credentialsId = account->valueAsInt(serviceCredentialsId(_serviceType), 0);
+    _authUsername = account->valueAsString("emailaddress");
+
+    if (_authUsername.isEmpty()) {
+        qMailLog(Messaging) << Q_FUNC_INFO
+                            << "SSO error: User name is emtpy.";
+        return false;
+    }
+
+    // Some plugins stores an identity per service.
+    // If there is no specific credentials for the specific service than we should check regular credentialsId.
+    // This allows to store different credentials for incoming and outgoing servers for example.
+    if (credentialsId == 0) {
+        credentialsId = account->credentialsId();
+    }
+
+    _identity = SignOn::Identity::existingIdentity(credentialsId, this);
+
+    if (_identity) {
+
+        qMailLog(Messaging) << Q_FUNC_INFO << "Creating SSO identity for the service " << _serviceType
+                            << " from account " << id.toULongLong()
+                            << " using authentication method " << _authMethod;
+       _session = _identity->createSession(_authMethod);
+        Q_ASSERT (_session);
+        ENFORCE(connect(_session, SIGNAL(response(SignOn::SessionData)),
+                        this, SLOT(ssoResponse(SignOn::SessionData))));
+        ENFORCE(connect(_session, SIGNAL(error(SignOn::Error)),
+                        this, SLOT(ssoSessionError(SignOn::Error))));
+        _waitForSso = true;
+        _authService = SSOAuthFactory::createService(_authMethod);
+        _session->process(_authService->sessionData(_accountProvider, _authParameters, false), _authMechanism);
+        return true;
+    } else {
+        _session = 0;
+        return false;
+    }
+}
+
+/*!
+    Deletes the SSO identity.
+*/
+void SSOSessionManager::deleteSsoIdentity()
+{
+    _ssoLogin = QByteArray();
+    _authMethod.clear();
+    _serviceType.clear();
+    if (_identity) {
+        Q_ASSERT (_session);
+        _identity->destroySession(_session);
+        delete _identity;
+        _identity = 0;
+    }
+}
+
+/*!
+    Recreates the SSO identity.
+
+    This function should be used when stored authentication details
+    are no longer valid. By default \a setUiPolicy is set to true,
+    in this case if the authentication plugin in use has a UI policy
+    defined this function can trigger additional processes that will request
+    actions from the user.
+*/
+void SSOSessionManager::recreateSsoIdentity(bool setUiPolicy)
+{
+    qMailLog(Messaging) << Q_FUNC_INFO << "Recreating SSO identity using auth method "
+                           << _authMethod;
+    if (_identity && _session && !_waitForSso) {
+        if (!_authService)
+            _authService = SSOAuthFactory::createService(_authMethod);
+
+        _waitForSso = true;
+        _session->process(_authService->sessionData(_accountProvider, _authParameters, setUiPolicy), _authMechanism);
+    } else {
+        _waitForSso = true;
+        emit ssoSessionError("SSO error: Identity is not valid, can't recreate session.");
+    }
+}
+
+QString SSOSessionManager::serviceCredentialsId(const QString &serviceType) const
+{
+    if (serviceType == "imap4") {
+        return "imap4/CredentialsId";
+    } else if (serviceType == "pop3") {
+        return "pop3/CredentialsId";
+    } else if (serviceType == "smtp") {
+        return "smtp/CredentialsId";
+    } else {
+        return QString();
+    }
+}
+
+void SSOSessionManager::ssoResponse(const SignOn::SessionData &sessionData)
+{
+    if (_waitForSso) {
+        _waitForSso = false;
+        if (!_authService)
+            _authService = SSOAuthFactory::createService(_authMethod);
+
+        QList<QByteArray> ssoLogin = _authService->authentication(sessionData, _serviceType,
+                                                                  _authUsername, _serviceAuthentication);
+        emit ssoSessionResponse(ssoLogin);
+    }
+}
+
+void SSOSessionManager::ssoSessionError(const SignOn::Error &code)
+{
+    if (_waitForSso) {
+        _waitForSso = false;
+        _ssoLogin = QByteArray();
+        emit ssoSessionError(QString("SSO error %1: %2").arg(code.type()).arg(code.message()));
+    }
+}
+
+/*!
+    Returns true if we are waiting for a reply
+    from accounts-sso framework, otherwise false.
+*/
+bool SSOSessionManager::waitForSso()
+{
+    return _waitForSso;
+}
+
diff --git a/src/libraries/qmfclient/ssosessionmanager.h b/src/libraries/qmfclient/ssosessionmanager.h
new file mode 100644
index 0000000..0a74ff7
--- /dev/null
+++ b/src/libraries/qmfclient/ssosessionmanager.h
@@ -0,0 +1,99 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valrio Valrio <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SSOSESSIONMANAGER_H
+#define SSOSESSIONMANAGER_H
+
+#include "ssoauthplugin.h"
+#include "qmailglobal.h"
+#include "qmailaccount.h"
+#include <QString>
+#include <qglobal.h>
+
+// Accounts
+#include <SignOn/Identity>
+#include <SignOn/SessionData>
+
+using namespace SignOn;
+
+class QMF_EXPORT SSOSessionManager : public QObject
+{
+    Q_OBJECT
+public:
+    SSOSessionManager(QObject* parent);
+    ~SSOSessionManager();
+
+    void cancel();
+    bool createSsoIdentity(const QMailAccountId &id,
+                           const QString &serviceType, int serviceAuthentication);
+    void deleteSsoIdentity();
+    void recreateSsoIdentity(bool setUiPolicy = true);
+    void removeSsoIdentity();
+    bool waitForSso();
+
+signals:
+    void ssoSessionResponse(const QList<QByteArray> &ssoLogin);
+    void ssoSessionError(const QString &error);
+
+protected slots:
+    void ssoResponse(const SignOn::SessionData &sessionData);
+    void ssoSessionError(const SignOn::Error &code);
+
+private:
+    bool authPluginAvailable(const QString &method) const;
+    QString serviceCredentialsId(const QString &serviceType) const;
+
+    int _serviceAuthentication;
+    bool _waitForSso;
+    QByteArray _ssoLogin;
+    QString _authMethod;
+    QString _authMechanism;
+    QString _authUsername;
+    QVariantMap _authParameters;
+    QString _serviceType;
+    QString _accountProvider;
+    QStringList _availableAuthMethods;
+    SSOAuthService *_authService;
+    SignOn::Identity *_identity;
+    SignOn::AuthSession *_session;
+};
+
+#endif // SSOSESSIONMANAGER_H
diff --git a/src/libraries/qmfmessageserver/qmailauthenticator.cpp b/src/libraries/qmfmessageserver/qmailauthenticator.cpp
index c7a57e1..6c50fe0 100644
--- a/src/libraries/qmfmessageserver/qmailauthenticator.cpp
+++ b/src/libraries/qmfmessageserver/qmailauthenticator.cpp
@@ -153,4 +153,3 @@ QByteArray QMailAuthenticator::getResponse(const QMailAccountConfiguration::Serv
     // Unknown service type and/or authentication type
     return QByteArray();
 }
-
diff --git a/src/plugins/messageservices/imap/imapauthenticator.cpp b/src/plugins/messageservices/imap/imapauthenticator.cpp
index 9054b6a..c338914 100644
--- a/src/plugins/messageservices/imap/imapauthenticator.cpp
+++ b/src/plugins/messageservices/imap/imapauthenticator.cpp
@@ -47,6 +47,7 @@
 #include <qmailauthenticator.h>
 #include <qmailtransport.h>
 #include <qmailnamespace.h>
+#include <qmaillog.h>
 
 namespace {
 
@@ -77,7 +78,34 @@ bool ImapAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceCo
     return QMailAuthenticator::useEncryption(svcCfg, capabilities);
 #endif
 }
+#ifdef USE_ACCOUNTS_QT
+QByteArray ImapAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QByteArray &ssoLogin)
+{
+    QString _password;
+    QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!result.isEmpty())
+        return QByteArray("AUTHENTICATE ") + result;
+
+    // If not handled by the authenticator, fall back to login
+    ImapConfiguration imapCfg(svcCfg);
+    if (ssoLogin.isEmpty()) {
+        _password = imapCfg.mailPassword();
+        qMailLog(IMAP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< imapCfg.id()
+                       << ", using password from accounts configuration";
+    } else {
+        return ssoLogin;
+    }
 
+    if (imapCfg.mailAuthentication() == QMail::PlainMechanism) {
+        QByteArray username(imapCfg.mailUserName().toLatin1());
+        QByteArray pass(_password.toLatin1());
+        return QByteArray("AUTHENTICATE PLAIN ") + QByteArray(username + '\0' + username + '\0' + pass).toBase64();
+    }
+
+    return QByteArray("LOGIN") + ' ' + ImapProtocol::quoteString(imapCfg.mailUserName().toLatin1())
+                               + ' ' + ImapProtocol::quoteString(_password.toLatin1());
+}
+#else
 QByteArray ImapAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
     QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
@@ -95,6 +123,7 @@ QByteArray ImapAuthenticator::getAuthentication(const QMailAccountConfiguration:
     return QByteArray("LOGIN") + ' ' + ImapProtocol::quoteString(imapCfg.mailUserName().toLatin1())
                                + ' ' + ImapProtocol::quoteString(imapCfg.mailPassword().toLatin1());
 }
+#endif
 
 QByteArray ImapAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge)
 {
diff --git a/src/plugins/messageservices/imap/imapauthenticator.h b/src/plugins/messageservices/imap/imapauthenticator.h
index a7e48b9..df949bf 100644
--- a/src/plugins/messageservices/imap/imapauthenticator.h
+++ b/src/plugins/messageservices/imap/imapauthenticator.h
@@ -51,7 +51,11 @@ class ImapAuthenticator
 {
 public:
     static bool useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#ifdef USE_ACCOUNTS_QT
+    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QByteArray &ssoLogin);
+#else
     static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#endif
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
 };
 
diff --git a/src/plugins/messageservices/imap/imapclient.cpp b/src/plugins/messageservices/imap/imapclient.cpp
index 59d170a..132337c 100644
--- a/src/plugins/messageservices/imap/imapclient.cpp
+++ b/src/plugins/messageservices/imap/imapclient.cpp
@@ -301,16 +301,23 @@ class IdleProtocol : public ImapProtocol {
     Q_OBJECT
 
 public:
+#ifdef USE_ACCOUNTS_QT
+    IdleProtocol(ImapClient *client, const QMailFolder &folder, const bool ssoAccount, QByteArray &ssoLogin);
+#else
     IdleProtocol(ImapClient *client, const QMailFolder &folder);
+#endif
     virtual ~IdleProtocol() {}
 
     virtual void handleIdling() { _client->idling(_folder.id()); }
     virtual bool open(const ImapConfiguration& config, qint64 bufferSize = 10*1024);
+#ifdef USE_ACCOUNTS_QT
+    int idleRetryDelay() { return _idleRetryDelay; }
+#endif
 
 signals:
     void idleNewMailNotification(QMailFolderId);
     void idleFlagsChangedNotification(QMailFolderId);
-    void openRequest();
+    void openRequest(IdleProtocol*);
 
 protected slots:
     virtual void idleContinuation(ImapCommand, const QString &);
@@ -330,8 +337,39 @@ private:
     QTimer _idleTimer; // Send a DONE command every 29 minutes
 #endif
     QTimer _idleRecoveryTimer; // Check command hasn't hung
+#ifdef USE_ACCOUNTS_QT
+    int _idleRetryDelay; // Try to restablish IDLE state
+    enum IdleRetryDelay { InitialIdleRetryDelay = 30 }; //seconds
+    bool _ssoAccount;
+    QByteArray &_ssoLogin;
+#endif
 };
 
+#ifdef USE_ACCOUNTS_QT
+IdleProtocol::IdleProtocol(ImapClient *client, const QMailFolder &folder, const bool ssoAccount, QByteArray &ssoLogin)
+    :_idleRetryDelay(InitialIdleRetryDelay),
+      _ssoAccount(ssoAccount),
+      _ssoLogin(ssoLogin)
+{
+    _client = client;
+    _folder = folder;
+    connect(this, SIGNAL(continuationRequired(ImapCommand, QString)),
+            this, SLOT(idleContinuation(ImapCommand, QString)) );
+    connect(this, SIGNAL(completed(ImapCommand, OperationStatus)),
+            this, SLOT(idleCommandTransition(ImapCommand, OperationStatus)) );
+    connect(this, SIGNAL(connectionError(int,QString)),
+            this, SLOT(idleTransportError()) );
+    connect(this, SIGNAL(connectionError(QMailServiceAction::Status::ErrorCode,QString)),
+            this, SLOT(idleTransportError()) );
+
+    _idleTimer.setSingleShot(true);
+    connect(&_idleTimer, SIGNAL(timeout()),
+            this, SLOT(idleTimeOut()));
+    _idleRecoveryTimer.setSingleShot(true);
+    connect(&_idleRecoveryTimer, SIGNAL(timeout()),
+            this, SLOT(idleErrorRecovery()));
+}
+#else
 IdleProtocol::IdleProtocol(ImapClient *client, const QMailFolder &folder)
 {
     _client = client;
@@ -352,6 +390,7 @@ IdleProtocol::IdleProtocol(ImapClient *client, const QMailFolder &folder)
     connect(&_idleRecoveryTimer, SIGNAL(timeout()),
             this, SLOT(idleErrorRecovery()));
 }
+#endif
 
 bool IdleProtocol::open(const ImapConfiguration& config, qint64 bufferSize)
 {
@@ -427,14 +466,28 @@ void IdleProtocol::idleCommandTransition(const ImapCommand command, const Operat
                     break;
                 }
             }
-
+#ifdef USE_ACCOUNTS_QT
+            // We are now connected
+            if (_ssoAccount)
+                sendLogin(config, _ssoLogin);
+            else
+                sendLogin(config, "");
+#else
             // We are now connected
             sendLogin(config);
+#endif
             return;
         }
         case IMAP_StartTLS:
         {
+#ifdef USE_ACCOUNTS_QT
+        if (_ssoAccount)
+            sendLogin(config, _ssoLogin);
+        else
+            sendLogin(config, "");
+#else
             sendLogin(config);
+#endif
             break;
         }
         case IMAP_Login: // Fall through
@@ -502,11 +555,91 @@ void IdleProtocol::idleErrorRecovery()
     const int oneHour = 60*60;
     _idleRecoveryTimer.stop();
 
-    _client->setIdleRetryDelay(qMin( oneHour, _client->idleRetryDelay()*2 ));
+#ifdef USE_ACCOUNTS_QT
+    if (connected() && _idleTimer.isActive()) {
+        qMailLog(IMAP) << objectName() << "IDLE: IMAP IDLE error recovery was successful. About to check for new mail.";
+        _idleRetryDelay = InitialIdleRetryDelay;
+        emit idleNewMailNotification(_folder.id()); // Check for new messages arriving while idle connection was down
+        emit idleFlagsChangedNotification(_folder.id());
+        return;
+    }
+    updateStatus(tr("Idle Error occurred"));
+
+    QTimer::singleShot(_idleRetryDelay*1000, this, SLOT(idleErrorRecovery()));
+    _idleRetryDelay = qMin( oneHour, _idleRetryDelay*2 );
 
-    emit openRequest();
+    emit openRequest(this);
+#else
+    _client->setIdleRetryDelay(qMin( oneHour, _client->idleRetryDelay()*2 ));
+    emit openRequest(this);
+#endif
 }
 
+#ifdef USE_ACCOUNTS_QT
+ImapClient::ImapClient(QObject* parent)
+    : QObject(parent),
+      _closeCount(0),
+      _waitingForIdle(false),
+      _idlesEstablished(false),
+      _qresyncEnabled(false),
+      _requestRapidClose(false),
+      _rapidClosing(false),
+      _idleRetryDelay(InitialIdleRetryDelay),
+      _pushConnectionsReserved(0),
+      _ssoSessionManager(0),
+      _loginFailed(false),
+      _sendLogin(false),
+      _recreateIdentity(true),
+      _accountUpdated(false)
+{
+    static int count(0);
+    ++count;
+
+    _protocol.setObjectName(QString("%1").arg(count));
+    _strategyContext = new ImapStrategyContext(this);
+    _strategyContext->setStrategy(&_strategyContext->synchronizeAccountStrategy);
+    connect(&_protocol, SIGNAL(completed(ImapCommand, OperationStatus)),
+            this, SLOT(commandCompleted(ImapCommand, OperationStatus)) );
+    connect(&_protocol, SIGNAL(mailboxListed(QString,QString)),
+            this, SLOT(mailboxListed(QString,QString)));
+    connect(&_protocol, SIGNAL(messageFetched(QMailMessage&, const QString &, bool)),
+            this, SLOT(messageFetched(QMailMessage&, const QString &, bool)) );
+    connect(&_protocol, SIGNAL(dataFetched(QString, QString, QString, int)),
+            this, SLOT(dataFetched(QString, QString, QString, int)) );
+    connect(&_protocol, SIGNAL(nonexistentUid(QString)),
+            this, SLOT(nonexistentUid(QString)) );
+    connect(&_protocol, SIGNAL(messageStored(QString)),
+            this, SLOT(messageStored(QString)) );
+    connect(&_protocol, SIGNAL(messageCopied(QString, QString)),
+            this, SLOT(messageCopied(QString, QString)) );
+    connect(&_protocol, SIGNAL(messageCreated(QMailMessageId, QString)),
+            this, SLOT(messageCreated(QMailMessageId, QString)) );
+    connect(&_protocol, SIGNAL(downloadSize(QString, int)),
+            this, SLOT(downloadSize(QString, int)) );
+    connect(&_protocol, SIGNAL(urlAuthorized(QString)),
+            this, SLOT(urlAuthorized(QString)) );
+    connect(&_protocol, SIGNAL(folderCreated(QString)),
+            this, SLOT(folderCreated(QString)));
+    connect(&_protocol, SIGNAL(folderDeleted(QMailFolder)),
+            this, SLOT(folderDeleted(QMailFolder)));
+    connect(&_protocol, SIGNAL(folderRenamed(QMailFolder, QString)),
+            this, SLOT(folderRenamed(QMailFolder, QString)));
+    connect(&_protocol, SIGNAL(updateStatus(QString)),
+            this, SLOT(transportStatus(QString)) );
+    connect(&_protocol, SIGNAL(connectionError(int,QString)),
+            this, SLOT(transportError(int,QString)) );
+    connect(&_protocol, SIGNAL(connectionError(QMailServiceAction::Status::ErrorCode,QString)),
+            this, SLOT(transportError(QMailServiceAction::Status::ErrorCode,QString)) );
+
+    _inactiveTimer.setSingleShot(true);
+    connect(&_inactiveTimer, SIGNAL(timeout()),
+            this, SLOT(connectionInactive()));
+
+    connect(QMailMessageBuffer::instance(), SIGNAL(flushed()), this, SLOT(messageBufferFlushed()));
+
+    connect (QMailStore::instance(), SIGNAL(accountsUpdated(QMailAccountIdList)), this, SLOT(onAccountsUpdated(QMailAccountIdList)));
+}
+#else
 ImapClient::ImapClient(QObject* parent)
     : QObject(parent),
       _closeCount(0),
@@ -563,6 +696,7 @@ ImapClient::ImapClient(QObject* parent)
 
     connect(QMailMessageBuffer::instance(), SIGNAL(flushed()), this, SLOT(messageBufferFlushed()));
 }
+#endif
 
 ImapClient::~ImapClient()
 {
@@ -579,6 +713,10 @@ ImapClient::~ImapClient()
         QMailMessageBuffer::instance()->removeCallback(callback);
     }
     delete _strategyContext;
+#ifdef USE_ACCOUNTS_QT
+    if (_ssoSessionManager)
+        _ssoSessionManager->deleteSsoIdentity();
+#endif
 }
 
 // Called to begin executing a strategy
@@ -652,8 +790,24 @@ void ImapClient::checkCommandResponse(ImapCommand command, OperationStatus statu
 
             case IMAP_Login:
             {
+#ifdef USE_ACCOUNTS_QT
+                // We try only once to recreate the sso identity and relogin,
+                // in order to allow user interaction if defined by the sso
+                // plugin.
+                if (!_loginFailed && _recreateIdentity) {
+                    _loginFailed = true;
+                    _sendLogin = true;
+                    ssoProcessLogin();
+                    return;
+                } else {
+                    _recreateIdentity = true;
+                    operationFailed(QMailServiceAction::Status::ErrLoginFailed, _protocol.lastError());
+                    return;
+                }
+#else
                 operationFailed(QMailServiceAction::Status::ErrLoginFailed, _protocol.lastError());
                 return;
+#endif
             }
 
             case IMAP_Full:
@@ -684,6 +838,11 @@ void ImapClient::checkCommandResponse(ImapCommand command, OperationStatus statu
         case IMAP_Unconnected:
             operationFailed(QMailServiceAction::Status::ErrNoConnection, _protocol.lastError());
             return;
+#ifdef USE_ACCOUNTS_QT
+        case IMAP_Login:
+            _loginFailed = false;
+            break;
+#endif
         default:
             break;
     }
@@ -744,7 +903,15 @@ void ImapClient::commandTransition(ImapCommand command, OperationStatus status)
                     }
                 }
                 emit updateStatus( tr("Logging in" ) );
+#ifdef USE_ACCOUNTS_QT
+                if (_ssoSessionManager) {
+                    _sendLogin = true;
+                    ssoProcessLogin();
+                } else
+                    _protocol.sendLogin(_config, "");
+#else
                 _protocol.sendLogin(_config);
+#endif
             }
             break;
         }
@@ -752,7 +919,15 @@ void ImapClient::commandTransition(ImapCommand command, OperationStatus status)
         case IMAP_Idle_Continuation:
         {
             emit updateStatus( tr("Logging in" ) );
+#ifdef USE_ACCOUNTS_QT
+            if (_ssoSessionManager) {
+                _sendLogin = true;
+                ssoProcessLogin();
+            } else
+                _protocol.sendLogin(_config, "");
+#else
             _protocol.sendLogin(_config);
+#endif
             break;
         }
         
@@ -788,9 +963,16 @@ void ImapClient::commandTransition(ImapCommand command, OperationStatus status)
                 account.setStatus(QMailAccount::CanReferenceExternalData, supportsReferences);
                 imapCfg.setPushCapable(_protocol.supportsCapability("IDLE"));
                 imapCfg.setCapabilities(_protocol.capabilities());
+#ifdef USE_ACCOUNTS_QT
+                if ((!QMailStore::instance()->updateAccount(&account)) ||
+                    (!QMailStore::instance()->updateAccount(&account, &_config))) {
+                    qWarning() << "Unable to update account" << account.id() << "to set imap4 configuration";
+                }
+#else
                 if (!QMailStore::instance()->updateAccount(&account, &_config)) {
                     qWarning() << "Unable to update account" << account.id() << "to set imap4 configuration";
                 }
+#endif
             }
 
             bool compressCapable(_protocol.capabilities().contains("COMPRESS=DEFLATE", Qt::CaseInsensitive));
@@ -1482,6 +1664,24 @@ void ImapClient::setAccount(const QMailAccountId &id)
     }
 
     _config = QMailAccountConfiguration(id);
+
+#ifdef USE_ACCOUNTS_QT
+    if (!_ssoSessionManager) {
+        ImapConfiguration imapCfg(_config);
+        _ssoSessionManager = new SSOSessionManager(this);
+         if (_ssoSessionManager->createSsoIdentity(id, "imap4", imapCfg.mailAuthentication())) {
+             ENFORCE(connect(_ssoSessionManager, SIGNAL(ssoSessionResponse(QList<QByteArray>))
+                             ,this, SLOT(onSsoSessionResponse(QList<QByteArray>))));
+             ENFORCE(connect(_ssoSessionManager, SIGNAL(ssoSessionError(QString))
+                             ,this, SLOT(onSsoSessionError(QString))));
+             qMailLog(IMAP) << Q_FUNC_INFO << "SSO identity is found for account id: "<< id;
+         } else {
+             delete _ssoSessionManager;
+             qMailLog(IMAP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                            << ", accounts configuration will be used";
+         }
+    }
+#endif
 }
 
 QMailAccountId ImapClient::account() const
@@ -1515,6 +1715,11 @@ void ImapClient::transportStatus(const QString& status)
 void ImapClient::cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text)
 {
     operationFailed(code, text);
+#ifdef USE_ACCOUNTS_QT
+    if (_ssoSessionManager) {
+        _ssoSessionManager->cancel();
+    }
+#endif
 }
 
 void ImapClient::retrieveOperationCompleted()
@@ -1701,27 +1906,39 @@ void ImapClient::monitor(const QMailFolderIdList &mailboxIds)
     foreach(QMailFolderId id, mailboxIds) {
         if (!_monitored.contains(id)) {
             ++count;
+#ifdef USE_ACCOUNTS_QT
+            bool ssoAccount = _ssoSessionManager != 0;
+            IdleProtocol *protocol = new IdleProtocol(this, QMailFolder(id), ssoAccount, _ssoLogin);
+#else
             IdleProtocol *protocol = new IdleProtocol(this, QMailFolder(id));
+#endif
             protocol->setObjectName(QString("I:%1").arg(count));
             _monitored.insert(id, protocol);
             connect(protocol, SIGNAL(idleNewMailNotification(QMailFolderId)),
                     this, SIGNAL(idleNewMailNotification(QMailFolderId)));
             connect(protocol, SIGNAL(idleFlagsChangedNotification(QMailFolderId)),
                     this, SIGNAL(idleFlagsChangedNotification(QMailFolderId)));
-            connect(protocol, SIGNAL(openRequest()),
-                    this, SLOT(idleOpenRequested()));
+            connect(protocol, SIGNAL(openRequest(IdleProtocol *)),
+                    this, SLOT(idleOpenRequested(IdleProtocol *)));
             protocol->open(imapCfg);
         }
     }
 }
 
-void ImapClient::idleOpenRequested()
+void ImapClient::idleOpenRequested(IdleProtocol *idleProtocol)
 {
     if (_protocol.inUse()) { // Setting up new idle connection may be in progress
-        qMailLog(IMAP) << _protocol.objectName() 
-                       << "IDLE: IMAP IDLE error recovery detected that the primary connection is "
-                          "busy. Retrying to establish IDLE state in" 
-                       << idleRetryDelay()/2 << "seconds.";
+#ifdef USE_ACCOUNTS_QT
+        qMailLog(IMAP) << _protocol.objectName()
+               << "IDLE: IMAP IDLE error recovery detected that the primary connection is "
+                  "busy. Retrying to establish IDLE state in"
+               << idleProtocol->idleRetryDelay()/2 << "seconds.";
+#else
+        qMailLog(IMAP) << _protocol.objectName()
+               << "IDLE: IMAP IDLE error recovery detected that the primary connection is "
+                  "busy. Retrying to establish IDLE state in"
+               << idleRetryDelay()/2 << "seconds.";
+#endif
         return;
     }
     _protocol.close();
@@ -1732,7 +1949,7 @@ void ImapClient::idleOpenRequested()
         delete protocol;
     }
     _idlesEstablished = false;
-    qMailLog(IMAP) << _protocol.objectName() 
+    qMailLog(IMAP) << _protocol.objectName()
                    << "IDLE: IMAP IDLE error recovery trying to establish IDLE state now.";
     emit restartPushEmail();
 }
@@ -1762,4 +1979,122 @@ void ImapClient::removeAllFromBuffer(QMailMessage *message)
     }
 }
 
+#ifdef USE_ACCOUNTS_QT
+void ImapClient::removeSsoIdentity(const QMailAccountId &accountId)
+{
+    //removing sso Identity
+    if (_config.id() == accountId) {
+        if (_ssoSessionManager) {
+            _ssoSessionManager->removeSsoIdentity();
+            delete _ssoSessionManager;
+        }
+    }
+}
+
+void ImapClient::ssoProcessLogin()
+{
+    if (_loginFailed && _recreateIdentity) {
+        // if account was updated try to recreate
+        // identity without asking the user for new
+        // credentials
+        if (_ssoSessionManager)
+            _ssoSessionManager->recreateSsoIdentity(!_accountUpdated);
+        else
+            operationFailed(QMailServiceAction::Status::ErrLoginFailed, "SSO Error: can't recreate identity.");
+    } else {
+        if (_sendLogin && !_ssoSessionManager->waitForSso()) {
+            _sendLogin = false;
+            _protocol.sendLogin(_config, _ssoLogin);
+        }
+    }
+}
+
+void ImapClient::onSsoSessionResponse(const QList<QByteArray> &ssoLogin)
+{
+    qMailLog(IMAP)  << "Got SSO response";
+    if (!ssoLogin.isEmpty()) {
+        if (_accountUpdated && _ssoLogin != ssoLogin[0]) {
+            _accountUpdated = false;
+            _ssoLogin = ssoLogin[0];
+        } else {
+            _ssoLogin = ssoLogin[0];
+        }
+    }
+
+    if (_loginFailed) {
+        _recreateIdentity = false;
+        commandTransition(IMAP_Init, OpPending);
+        return;
+    }
+    if (_sendLogin) {
+        _protocol.sendLogin(_config, _ssoLogin);
+    }
+}
+
+void ImapClient::onSsoSessionError(const QString &error)
+{
+    // Reset vars
+    _loginFailed = false;
+    _sendLogin = false;
+    _recreateIdentity = true;
+    qMailLog(IMAP) <<  "Got SSO error:" << error;
+    operationFailed(QMailServiceAction::Status::ErrLoginFailed, error);
+}
+
+void ImapClient::onAccountsUpdated(const QMailAccountIdList &list)
+{
+    if (list.contains(_config.id())) {
+
+        ImapConfiguration imapCfg1(_config);
+        // copying here as the data is shared
+        QMailAccountConfiguration config = QMailAccountConfiguration(_config.id());
+        ImapConfiguration imapCfg2(config);
+
+        if (!imapCfg1.isValid()) {
+            qMailLog(IMAP) << Q_FUNC_INFO << "current config is invalid";
+            return;
+        }
+
+        if (!imapCfg2.isValid()) {
+            qMailLog(IMAP) << Q_FUNC_INFO << "invalid config from db";
+            return;
+        }
+
+        if (_ssoSessionManager)
+            _accountUpdated = true;
+
+        qMailLog(IMAP) << Q_FUNC_INFO << imapCfg1.mailUserName() ;
+        // compare config modified by the User
+        const bool& notEqual = (imapCfg1.mailUserName() != imapCfg2.mailUserName()) ||
+                               (imapCfg1.mailPassword() != imapCfg2.mailPassword()) ||
+                               (imapCfg1.mailServer() != imapCfg2.mailServer()) ||
+                               (imapCfg1.mailPort() != imapCfg2.mailPort()) ||
+                               (imapCfg1.mailEncryption() != imapCfg2.mailEncryption()) ||
+                               (imapCfg1.pushEnabled() != imapCfg2.pushEnabled());
+        if (notEqual)
+            closeIdleConnections();
+
+        if (imapCfg1.pushEnabled() != imapCfg2.pushEnabled()) {
+            if (imapCfg2.pushEnabled())
+                emit restartPushEmail();
+        }
+    }
+}
+
+void ImapClient::closeIdleConnections()
+{
+    qMailLog(IMAP) << Q_FUNC_INFO << "Account was modified. Closing connections";
+
+    closeConnection();
+    // closing idle connections
+    foreach(const QMailFolderId &id, _monitored.keys()) {
+        IdleProtocol *protocol = _monitored.take(id);
+        protocol->close();
+        delete protocol;
+    }
+    _idlesEstablished = false;
+}
+
+#endif
+
 #include "imapclient.moc"
diff --git a/src/plugins/messageservices/imap/imapclient.h b/src/plugins/messageservices/imap/imapclient.h
index cb1eb5f..c1116b7 100644
--- a/src/plugins/messageservices/imap/imapclient.h
+++ b/src/plugins/messageservices/imap/imapclient.h
@@ -55,6 +55,10 @@
 #include <qmailmessageclassifier.h>
 #include <qmailmessageserver.h>
 
+#ifdef USE_ACCOUNTS_QT
+#include <ssosessionmanager.h>
+#endif
+
 
 class ImapStrategy;
 class ImapStrategyContext;
@@ -70,6 +74,10 @@ public:
     ~ImapClient();
 
     void setAccount(const QMailAccountId& accountId);
+#ifdef USE_ACCOUNTS_QT
+    void removeSsoIdentity(const QMailAccountId& accountId);
+    void closeIdleConnections();
+#endif
     QMailAccountId account() const;
     void requestRapidClose() { _requestRapidClose = true; } // Close connection ASAP, unless interactive checking occurred recently
 
@@ -146,12 +154,21 @@ protected slots:
     void checkCommandResponse(const ImapCommand, const OperationStatus);
     void commandTransition(const ImapCommand, const OperationStatus);
     void transportStatus(const QString& status);
-    void idleOpenRequested();
+    void idleOpenRequested(IdleProtocol*);
     void messageBufferFlushed();
 
+#ifdef USE_ACCOUNTS_QT
+    void onAccountsUpdated(const QMailAccountIdList& list);
+    void onSsoSessionError(const QString &error);
+    void onSsoSessionResponse(const QList<QByteArray> &ssoLogin);
+#endif
+
 private:
     friend class ImapStrategyContextBase;
 
+#ifdef USE_ACCOUNTS_QT
+    void ssoProcessLogin();
+#endif
     void deactivateConnection();
     void retrieveOperationCompleted();
 
@@ -185,6 +202,15 @@ private:
     int _pushConnectionsReserved;
 
     QMap<QMailMessageId,QString> detachedTempFiles;
+
+#ifdef USE_ACCOUNTS_QT
+    SSOSessionManager* _ssoSessionManager;
+    bool _loginFailed;
+    bool _sendLogin;
+    bool _recreateIdentity;
+    bool _accountUpdated;
+    QByteArray _ssoLogin;
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/imap/imapprotocol.cpp b/src/plugins/messageservices/imap/imapprotocol.cpp
index 4f2e057..2fa5503 100644
--- a/src/plugins/messageservices/imap/imapprotocol.cpp
+++ b/src/plugins/messageservices/imap/imapprotocol.cpp
@@ -543,8 +543,11 @@ class LoginState : public ImapState
 public:
     LoginState() : ImapState(IMAP_Login, "Login") { LoginState::init(); }
 
+#ifdef USE_ACCOUNTS_QT
+    void setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities, const QByteArray &ssoLogin);
+#else
     void setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities);
-
+#endif
     virtual void init();
     virtual QString transmit(ImapContext *c);
     virtual bool continuationResponse(ImapContext *c, const QString &line);
@@ -553,24 +556,43 @@ public:
 private:
     QMailAccountConfiguration _config;
     QStringList _capabilities;
+#ifdef USE_ACCOUNTS_QT
+    QByteArray _ssoLogin;
+#endif
 };
 
+#ifdef USE_ACCOUNTS_QT
+void LoginState::setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities, const QByteArray &ssoLogin)
+{
+    _config = config;
+    _capabilities = capabilities;
+    _ssoLogin = ssoLogin;
+}
+#else
 void LoginState::setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities)
 {
     _config = config;
     _capabilities = capabilities;
 }
+#endif
 
 void LoginState::init()
 {
     ImapState::init();
     _config = QMailAccountConfiguration();
     _capabilities = QStringList();
+#ifdef USE_ACCOUNTS_QT
+    _ssoLogin = QByteArray();
+#endif
 }
 
 QString LoginState::transmit(ImapContext *c)
 {
+#ifdef USE_ACCOUNTS_QT
+    return c->sendCommand(ImapAuthenticator::getAuthentication(_config.serviceConfiguration("imap4"), _capabilities, _ssoLogin));
+#else
     return c->sendCommand(ImapAuthenticator::getAuthentication(_config.serviceConfiguration("imap4"), _capabilities));
+#endif
 }
 
 bool LoginState::continuationResponse(ImapContext *c, const QString &received)
@@ -578,9 +600,12 @@ bool LoginState::continuationResponse(ImapContext *c, const QString &received)
     // The server input is Base64 encoded
     QByteArray challenge = QByteArray::fromBase64(received.toLatin1());
     QByteArray response(ImapAuthenticator::getResponse(_config.serviceConfiguration("imap4"), challenge));
-
     if (!response.isEmpty()) {
         c->sendData(response.toBase64());
+    } else {
+        // Challenge response is empty
+        // send a empty response.
+        c->sendData("");
     }
 
     return false;
@@ -3025,11 +3050,19 @@ void ImapProtocol::sendStartTLS()
     _fsm->setState(&_fsm->startTlsState);
 }
 
+#ifdef USE_ACCOUNTS_QT
+void ImapProtocol::sendLogin(const QMailAccountConfiguration &config , const QByteArray &ssoLogin)
+{
+    _fsm->loginState.setConfiguration(config, _capabilities, ssoLogin);
+    _fsm->setState(&_fsm->loginState);
+}
+#else
 void ImapProtocol::sendLogin( const QMailAccountConfiguration &config )
 {
     _fsm->loginState.setConfiguration(config, _capabilities);
     _fsm->setState(&_fsm->loginState);
 }
+#endif
 
 void ImapProtocol::sendLogout()
 {
@@ -3596,7 +3629,7 @@ QString ImapProtocol::quoteString(const QString& input)
 
 QByteArray ImapProtocol::quoteString(const QByteArray& input)
 {
-    return quoteString(QString(input)).toLatin1();
+    return quoteString(QString::fromLatin1(input)).toLatin1();
 }
 
 void ImapProtocol::createMail(const QString &uid, const QDateTime &timeStamp, int size, uint flags, const QString &detachedFile, const QStringList& structure)
diff --git a/src/plugins/messageservices/imap/imapprotocol.h b/src/plugins/messageservices/imap/imapprotocol.h
index 390a35f..51c96b5 100644
--- a/src/plugins/messageservices/imap/imapprotocol.h
+++ b/src/plugins/messageservices/imap/imapprotocol.h
@@ -181,7 +181,11 @@ public:
     /*  Valid in non-authenticated state only    */
     void sendCapability();
     void sendStartTLS();
+#ifdef USE_ACCOUNTS_QT
+    void sendLogin(const QMailAccountConfiguration &config, const QByteArray &ssoLogin);
+#else
     void sendLogin(const QMailAccountConfiguration &config);
+#endif
 
     /* Valid in authenticated state only    */
     void sendList(const QMailFolder &reference, const QString &mailbox);
diff --git a/src/plugins/messageservices/imap/imapservice.cpp b/src/plugins/messageservices/imap/imapservice.cpp
index 4c37083..2b2a386 100644
--- a/src/plugins/messageservices/imap/imapservice.cpp
+++ b/src/plugins/messageservices/imap/imapservice.cpp
@@ -219,6 +219,12 @@ private:
 bool ImapService::Source::retrieveFolderList(const QMailAccountId &accountId, const QMailFolderId &folderId, bool descending)
 {
     Q_ASSERT(!_unavailable);
+    // Make sure service is still available, for e.g
+    // long sync operation is ongoing and account
+    // is disabled in the meantime.
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -291,6 +297,9 @@ bool ImapService::Source::retrieveNewMessages(const QMailAccountId &accountId, c
 bool ImapService::Source::retrieveMessageLists(const QMailAccountId &accountId, const QMailFolderIdList &_folderIds, uint minimum, const QMailMessageSortKey &sort, bool accountCheck)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -333,6 +342,9 @@ bool ImapService::Source::retrieveMessageLists(const QMailAccountId &accountId,
 bool ImapService::Source::retrieveMessages(const QMailMessageIdList &messageIds, QMailRetrievalAction::RetrievalSpecification spec)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -381,6 +393,9 @@ bool ImapService::Source::retrieveMessages(const QMailMessageIdList &messageIds,
 bool ImapService::Source::retrieveMessagePart(const QMailMessagePart::Location &partLocation)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -418,6 +433,9 @@ bool ImapService::Source::retrieveMessagePart(const QMailMessagePart::Location &
 bool ImapService::Source::retrieveMessageRange(const QMailMessageId &messageId, uint minimum)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -459,6 +477,9 @@ bool ImapService::Source::retrieveMessageRange(const QMailMessageId &messageId,
 bool ImapService::Source::retrieveMessagePartRange(const QMailMessagePart::Location &partLocation, uint minimum)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -501,6 +522,9 @@ bool ImapService::Source::retrieveMessagePartRange(const QMailMessagePart::Locat
 bool ImapService::Source::retrieveAll(const QMailAccountId &accountId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -552,6 +576,9 @@ void ImapService::Source::queueDisconnectedOperations(const QMailAccountId &acco
 bool ImapService::Source::exportUpdates(const QMailAccountId &accountId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -600,6 +627,8 @@ bool ImapService::Source::synchronize(const QMailAccountId &accountId)
 bool ImapService::Source::deleteMessages(const QMailMessageIdList &allIds)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
     // If a server crash has occurred duplicate messages may exist in the store.
     // A duplicate message is one that refers to the same serverUid as another message in the same account & folder.
     // Ensure that when a duplicate message is deleted no message is deleted from the server.
@@ -659,6 +688,9 @@ bool ImapService::Source::deleteMessages(const QMailMessageIdList &allIds)
 bool ImapService::Source::doDelete(const QMailMessageIdList &ids)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -684,6 +716,9 @@ bool ImapService::Source::doDelete(const QMailMessageIdList &ids)
 bool ImapService::Source::copyMessages(const QMailMessageIdList &messageIds, const QMailFolderId &destinationId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -715,6 +750,9 @@ bool ImapService::Source::copyMessages(const QMailMessageIdList &messageIds, con
 bool ImapService::Source::moveMessages(const QMailMessageIdList &messageIds, const QMailFolderId &destinationId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -781,6 +819,9 @@ bool ImapService::Source::moveMessages(const QMailMessageIdList &messageIds, con
 bool ImapService::Source::flagMessages(const QMailMessageIdList &messageIds, quint64 setMask, quint64 unsetMask)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -976,6 +1017,9 @@ bool ImapService::Source::flagMessages(const QMailMessageIdList &messageIds, qui
 bool ImapService::Source::createFolder(const QString &name, const QMailAccountId &accountId, const QMailFolderId &parentId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1063,6 +1107,9 @@ bool ImapService::Source::createStandardFolders(const QMailAccountId &accountId)
 bool ImapService::Source::deleteFolder(const QMailFolderId &folderId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1088,6 +1135,9 @@ bool ImapService::Source::deleteFolder(const QMailFolderId &folderId)
 bool ImapService::Source::renameFolder(const QMailFolderId &folderId, const QString &name)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1133,7 +1183,9 @@ bool ImapService::Source::countMessages(const QMailMessageKey &searchCriteria, c
 
 bool ImapService::Source::searchMessages(const QMailMessageKey &searchCriteria, const QString &bodyText, quint64 limit, const QMailMessageSortKey &sort, bool count)
 {
-    Q_ASSERT(!_unavailable);
+    Q_ASSERT(!_unavailable);    
+    if (!_service)
+        return false;
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1154,6 +1206,9 @@ bool ImapService::Source::searchMessages(const QMailMessageKey &searchCriteria,
 
 bool ImapService::Source::cancelSearch()
 {
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1169,6 +1224,9 @@ bool ImapService::Source::cancelSearch()
 bool ImapService::Source::prepareMessages(const QList<QPair<QMailMessagePart::Location, QMailMessagePart::Location> > &messageIds)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1263,6 +1321,9 @@ bool ImapService::Source::initiateStrategy()
 // Copy or Move Completed
 void ImapService::Source::messageCopyCompleted(QMailMessage &message, const QMailMessage &original)
 {
+    if (!_service)
+        return;
+
     if (_service->_client->strategy()->error()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("Destination message failed to match source message"));
         return;
@@ -1568,6 +1629,11 @@ void ImapService::accountsUpdated(const QMailAccountIdList &ids)
 
 ImapService::~ImapService()
 {
+#ifdef USE_ACCOUNTS_QT
+    //If account was deleted, we should remove appropriate signon identity from the signon.db
+    if (!_accountId.isValid())
+        _client->removeSsoIdentity(_accountId);
+#endif
     disable();
     delete _source;
 }
diff --git a/src/plugins/messageservices/pop/popauthenticator.cpp b/src/plugins/messageservices/pop/popauthenticator.cpp
index 23f0206..f548d08 100644
--- a/src/plugins/messageservices/pop/popauthenticator.cpp
+++ b/src/plugins/messageservices/pop/popauthenticator.cpp
@@ -40,12 +40,10 @@
 ****************************************************************************/
 
 #include "popauthenticator.h"
-
 #include "popconfiguration.h"
-
 #include <qmailauthenticator.h>
 #include <qmailtransport.h>
-
+#include <qmaillog.h>
 
 bool PopAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
@@ -76,6 +74,30 @@ bool PopAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceCon
 #endif
 }
 
+#ifdef USE_ACCOUNTS_QT
+QList<QByteArray> PopAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QList<QByteArray> &ssoLogin)
+{
+    QList<QByteArray> result;
+
+    QByteArray auth(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!auth.isEmpty()) {
+        result.append(QByteArray("AUTH ") + auth);
+    } else {
+        // If not handled by the authenticator, fall back to user/pass
+        PopConfiguration popCfg(svcCfg);
+        if(ssoLogin.isEmpty()){
+            qMailLog(POP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< popCfg.id()
+                           << ", using password from accounts configuration";
+        } else {
+            return ssoLogin;
+        }
+        result.append(QByteArray("USER ") + popCfg.mailUserName().toLatin1());
+        result.append(QByteArray("PASS ") + popCfg.mailPassword().toLatin1());
+    }
+
+    return result;
+}
+#else
 QList<QByteArray> PopAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
     QList<QByteArray> result;
@@ -93,6 +115,7 @@ QList<QByteArray> PopAuthenticator::getAuthentication(const QMailAccountConfigur
 
     return result;
 }
+#endif
 
 QByteArray PopAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge)
 {
diff --git a/src/plugins/messageservices/pop/popauthenticator.h b/src/plugins/messageservices/pop/popauthenticator.h
index 1dc2e6e..c983edc 100644
--- a/src/plugins/messageservices/pop/popauthenticator.h
+++ b/src/plugins/messageservices/pop/popauthenticator.h
@@ -51,7 +51,11 @@ class PopAuthenticator
 {
 public:
     static bool useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#ifdef USE_ACCOUNTS_QT
+    static QList<QByteArray> getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QList<QByteArray> &ssoLogin);
+#else
     static QList<QByteArray> getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#endif
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
 };
 
diff --git a/src/plugins/messageservices/pop/popclient.cpp b/src/plugins/messageservices/pop/popclient.cpp
index 2643c52..fbb8605 100644
--- a/src/plugins/messageservices/pop/popclient.cpp
+++ b/src/plugins/messageservices/pop/popclient.cpp
@@ -55,7 +55,6 @@
 #include <unistd.h>
 #endif
 
-
 class MessageFlushedWrapper : public QMailMessageBufferFlushCallback
 {
     PopClient *context;
@@ -74,6 +73,29 @@ public:
     }
 };
 
+#ifdef USE_ACCOUNTS_QT
+PopClient::PopClient(QObject* parent)
+    : QObject(parent),
+      selected(false),
+      deleting(false),
+      headerLimit(0),
+      additional(0),
+      partialContent(false),
+      dataStream(new LongStream),
+      transport(0),
+      testing(false),
+      pendingDeletes(false),
+      ssoSessionManager(0),
+      loginFailed(false),
+      sendLogin(false),
+      accountUpdated(false)
+{
+    inactiveTimer.setSingleShot(true);
+    connect(&inactiveTimer, SIGNAL(timeout()), this, SLOT(connectionInactive()));
+    connect(QMailMessageBuffer::instance(), SIGNAL(flushed()), this, SLOT(messageBufferFlushed()));
+    connect(QMailStore::instance(), SIGNAL(accountsUpdated(QMailAccountIdList)), this, SLOT(onAccountsUpdated(QMailAccountIdList)));
+}
+#else
 PopClient::PopClient(QObject* parent)
     : QObject(parent),
       selected(false),
@@ -90,6 +112,7 @@ PopClient::PopClient(QObject* parent)
     connect(&inactiveTimer, SIGNAL(timeout()), this, SLOT(connectionInactive()));
     connect(QMailMessageBuffer::instance(), SIGNAL(flushed()), this, SLOT(messageBufferFlushed()));
 }
+#endif
 
 PopClient::~PopClient()
 {
@@ -99,6 +122,10 @@ PopClient::~PopClient()
 
     delete dataStream;
     delete transport;
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager)
+        ssoSessionManager->deleteSsoIdentity();
+#endif
 }
 
 void PopClient::messageBufferFlushed()
@@ -165,6 +192,7 @@ void PopClient::newConnection()
     testing = false;
     pendingDeletes = false;
     lastStatusTimer.start();
+
     if (transport && transport->connected()) {
         if (selected) {
             // Re-use the existing connection
@@ -219,6 +247,23 @@ void PopClient::setAccount(const QMailAccountId &id)
     }
 
     config = QMailAccountConfiguration(id);
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoSessionManager) {
+        PopConfiguration popCfg(config);
+        ssoSessionManager = new SSOSessionManager(this);
+        ssoSessionManager->createSsoIdentity(id, "pop3", popCfg.mailEncryption());
+        if (ssoSessionManager->createSsoIdentity(id, "pop3", popCfg.mailEncryption())) {
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionResponse(QList<QByteArray>))
+                            ,this, SLOT(onSsoSessionResponse(QList<QByteArray>))));
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionError(QString)),this, SLOT(onSsoSessionError(QString))));
+            qMailLog(POP) << Q_FUNC_INFO << "SSO identity is found for account id: "<< id;
+        } else {
+            delete ssoSessionManager;
+            qMailLog(POP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                          << ", accounts configuration will be used";
+        }
+    }
+#endif
 }
 
 QMailAccountId PopClient::accountId() const
@@ -488,7 +533,16 @@ void PopClient::processResponse(const QString &response)
     {
         if (response[0] != '+') {
             // Authentication failed
+#ifdef USE_ACCOUNTS_QT
+            if (ssoSessionManager && !loginFailed) {
+                loginFailed = true;
+                ssoProcessLogin();
+            } else {
+                operationFailed(QMailServiceAction::Status::ErrLoginFailed, "");
+            }
+#else
             operationFailed(QMailServiceAction::Status::ErrLoginFailed, "");
+#endif
         } else {
             if ((response.length() > 2) && (response[1] == ' ')) {
                 // This is a continuation containing a challenge string (in Base64)
@@ -702,7 +756,11 @@ void PopClient::nextAction()
         emit updateStatus(tr("Logging in"));
 
         // Get the login command sequence to use
+#ifdef USE_ACCOUNTS_QT
+        authCommands = PopAuthenticator::getAuthentication(config.serviceConfiguration("pop3"), capabilities, ssoLogin);
+#else
         authCommands = PopAuthenticator::getAuthentication(config.serviceConfiguration("pop3"), capabilities);
+#endif
 
         nextStatus = Auth;
         nextCommand = authCommands.takeFirst();
@@ -1199,6 +1257,11 @@ void PopClient::checkForNewMessages()
 void PopClient::cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text)
 {
     operationFailed(code, text);
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager) {
+        ssoSessionManager->cancel();
+    }
+#endif
 }
 
 void PopClient::retrieveOperationCompleted()
@@ -1296,3 +1359,63 @@ void PopClient::removeAllFromBuffer(QMailMessage *message)
         _bufferedMessages.remove(i);
     }
 }
+
+#ifdef USE_ACCOUNTS_QT
+void PopClient::removeSsoIdentity(const QMailAccountId &accountId)
+{
+    if (config.id() == accountId) {
+        if (ssoSessionManager) {
+            ssoSessionManager->removeSsoIdentity();
+            delete ssoSessionManager;
+        }
+    }
+}
+
+void PopClient::onSsoSessionResponse(const QList<QByteArray> &ssoCredentials)
+{
+    qMailLog(POP)  << "Got SSO response";
+    if(!ssoCredentials.isEmpty()) {
+        ssoLogin = ssoCredentials;
+        if (sendLogin) {
+            sendLogin = false;
+            newConnection();
+        }
+    }
+}
+
+void PopClient::onSsoSessionError(const QString &error)
+{
+    loginFailed = false;
+    sendLogin = false;
+    qMailLog(POP) <<  "Got SSO error:" << error;
+    operationFailed(QMailSearchAction::Status::ErrLoginFailed, error);
+}
+
+void PopClient::ssoProcessLogin()
+{
+    if (loginFailed) {
+        if (ssoSessionManager) {
+            sendLogin = true;
+            ssoSessionManager->recreateSsoIdentity(!accountUpdated);
+        } else
+            operationFailed(QMailServiceAction::Status::ErrLoginFailed, "SSO Error: can't recreate identity.");
+    } else {
+        status = Connected;
+        nextAction();
+    }
+}
+
+void PopClient::onAccountsUpdated(const QMailAccountIdList &list)
+{
+    if (!list.contains(accountId()))
+        return;
+
+    QMailAccount acc(accountId());
+    bool isEnabled(acc.status() & QMailAccount::Enabled);
+    if (!isEnabled)
+        return;
+    accountUpdated = true;
+    setAccount(accountId());
+}
+
+#endif
diff --git a/src/plugins/messageservices/pop/popclient.h b/src/plugins/messageservices/pop/popclient.h
index e890b84..ff9c9de 100644
--- a/src/plugins/messageservices/pop/popclient.h
+++ b/src/plugins/messageservices/pop/popclient.h
@@ -54,6 +54,10 @@
 #include <qmailtransport.h>
 #include <qmailmessagebuffer.h>
 
+#ifdef USE_ACCOUNTS_QT
+#include <ssosessionmanager.h>
+#endif
+
 class LongStream;
 class QMailTransport;
 class QMailAccount;
@@ -90,6 +94,10 @@ public:
     void messageFlushed(QMailMessage &message, bool isComplete);
     void removeAllFromBuffer(QMailMessage *message);
 
+#ifdef USE_ACCOUNTS_QT
+    void removeSsoIdentity(const QMailAccountId &accountId);
+#endif
+
 signals:
     void errorOccurred(int, const QString &);
     void errorOccurred(QMailServiceAction::Status::ErrorCode, const QString &);
@@ -107,10 +115,19 @@ protected slots:
     void connected(QMailTransport::EncryptType encryptType);
     void transportError(int, QString msg);
 
+#ifdef USE_ACCOUNTS_QT
+    void onAccountsUpdated(const QMailAccountIdList& list);
+    void onSsoSessionError(const QString &error);
+    void onSsoSessionResponse(const QList<QByteArray> &ssoCredentials);
+#endif
+
     void connectionInactive();
     void incomingData();
 
 private:
+#ifdef USE_ACCOUNTS_QT
+    void ssoProcessLogin();
+#endif
     void deactivateConnection();
     int nextMsgServerPos();
     int msgPosFromUidl(QString uidl);
@@ -189,6 +206,14 @@ private:
     QVector<QMailMessageBufferFlushCallback*> callbacks;
     bool testing;
     bool pendingDeletes;
+
+#ifdef USE_ACCOUNTS_QT
+    SSOSessionManager* ssoSessionManager;
+    bool loginFailed;
+    bool sendLogin;
+    bool accountUpdated;
+    QList<QByteArray> ssoLogin;
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/pop/popservice.cpp b/src/plugins/messageservices/pop/popservice.cpp
index ef104b0..d7b7390 100644
--- a/src/plugins/messageservices/pop/popservice.cpp
+++ b/src/plugins/messageservices/pop/popservice.cpp
@@ -109,6 +109,9 @@ private:
 
 bool PopService::Source::retrieveFolderList(const QMailAccountId &accountId, const QMailFolderId &folderId, bool descending)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -131,6 +134,8 @@ bool PopService::Source::retrieveFolderList(const QMailAccountId &accountId, con
 
 bool PopService::Source::retrieveMessageLists(const QMailAccountId &accountId, const QMailFolderIdList &folderIds, uint minimum, const QMailMessageSortKey &sort)
 {
+    if (!_service)
+        return false;
     if (folderIds.isEmpty()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No folders specified"));
         return false;
@@ -141,6 +146,9 @@ bool PopService::Source::retrieveMessageLists(const QMailAccountId &accountId, c
 
 bool PopService::Source::retrieveMessageList(const QMailAccountId &accountId, const QMailFolderId &folderId, uint minimum, const QMailMessageSortKey &sort)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -171,6 +179,9 @@ bool PopService::Source::retrieveMessageList(const QMailAccountId &accountId, co
 
 bool PopService::Source::retrieveMessages(const QMailMessageIdList &messageIds, QMailRetrievalAction::RetrievalSpecification spec)
 {
+    if (!_service)
+        return false;
+
     if (messageIds.isEmpty()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No messages to retrieve"));
         return false;
@@ -197,6 +208,9 @@ bool PopService::Source::retrieveMessages(const QMailMessageIdList &messageIds,
 
 bool PopService::Source::retrieveAll(const QMailAccountId &accountId)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -210,6 +224,9 @@ bool PopService::Source::retrieveAll(const QMailAccountId &accountId)
 
 bool PopService::Source::exportUpdates(const QMailAccountId &accountId)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -227,6 +244,9 @@ bool PopService::Source::synchronize(const QMailAccountId &accountId)
 
 bool PopService::Source::deleteMessages(const QMailMessageIdList &messageIds)
 {
+    if (!_service)
+        return false;
+
     if (messageIds.isEmpty()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No messages to delete"));
         return false;
@@ -332,6 +352,11 @@ PopService::PopService(const QMailAccountId &accountId)
 
 PopService::~PopService()
 {
+#ifdef USE_ACCOUNTS_QT
+    //If account was deleted, we should remove appropriate signon identity from the signon.db
+    if (!accountId().isValid())
+        _client.removeSsoIdentity(accountId());
+#endif
     delete _source;
 }
 
diff --git a/src/plugins/messageservices/smtp/smtp.pro b/src/plugins/messageservices/smtp/smtp.pro
index aacaffc..ec6a48f 100644
--- a/src/plugins/messageservices/smtp/smtp.pro
+++ b/src/plugins/messageservices/smtp/smtp.pro
@@ -12,6 +12,24 @@ equals(QT_MAJOR_VERSION, 5) {
 }
 
 QT = core network
+
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    equals(QT_MAJOR_VERSION, 4) {
+        # accounts dependencies
+        PKGCONFIG += accounts-qt
+        # sso dependencies
+        PKGCONFIG += libsignon-qt
+    }
+    equals(QT_MAJOR_VERSION, 5) {
+        # accounts dependencies
+        PKGCONFIG += accounts-qt5
+        # sso dependencies
+        PKGCONFIG += libsignon-qt5
+    }
+}
+
 DEPENDPATH += .
 
 INCLUDEPATH += . ../../../libraries/qmfclient \
diff --git a/src/plugins/messageservices/smtp/smtpauthenticator.cpp b/src/plugins/messageservices/smtp/smtpauthenticator.cpp
index 252684a..c270fac 100644
--- a/src/plugins/messageservices/smtp/smtpauthenticator.cpp
+++ b/src/plugins/messageservices/smtp/smtpauthenticator.cpp
@@ -44,7 +44,7 @@
 #include "smtpconfiguration.h"
 
 #include <qmailauthenticator.h>
-
+#include <qmaillog.h>
 
 namespace {
 
@@ -52,6 +52,46 @@ QMap<QMailAccountId, QList<QByteArray> > gResponses;
 
 }
 
+#ifdef USE_ACCOUNTS_QT
+QByteArray SmtpAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, QList<QByteArray> &ssoLogin)
+{
+    QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!result.isEmpty())
+        return result.prepend("AUTH ");
+
+#ifndef QT_NO_OPENSSL
+    SmtpConfiguration smtpCfg(svcCfg);
+    if (smtpCfg.smtpAuthentication() != SmtpConfiguration::Auth_NONE) {
+        QMailAccountId id(smtpCfg.id());
+        QByteArray username(smtpCfg.smtpUsername().toLatin1());
+        QByteArray pass;
+        if (ssoLogin.isEmpty()) {
+            pass = smtpCfg.smtpPassword().toLatin1();
+            qMailLog(SMTP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                           << ", using password from accounts configuration";
+        } else {
+            QList<QByteArray> responses = ssoLogin;
+            QByteArray res = responses.takeFirst();
+            gResponses[id] = responses;
+            return res;
+        }
+
+        if (smtpCfg.smtpAuthentication() == SmtpConfiguration::Auth_LOGIN) {
+            result = QByteArray("LOGIN");
+            gResponses[id] = (QList<QByteArray>() << username << pass);
+        } else if (smtpCfg.smtpAuthentication() == SmtpConfiguration::Auth_PLAIN) {
+            result = QByteArray("PLAIN");
+            gResponses[id] = (QList<QByteArray>() << QByteArray(username + '\0' + username + '\0' + pass));
+        }
+    }
+#endif
+
+    if (!result.isEmpty()) {
+        result.prepend("AUTH ");
+    }
+    return result;
+}
+#else
 QByteArray SmtpAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
     QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
@@ -80,6 +120,7 @@ QByteArray SmtpAuthenticator::getAuthentication(const QMailAccountConfiguration:
     }
     return result;
 }
+#endif
 
 QByteArray SmtpAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge)
 {
@@ -98,4 +139,3 @@ QByteArray SmtpAuthenticator::getResponse(const QMailAccountConfiguration::Servi
 
     return result;
 }
-
diff --git a/src/plugins/messageservices/smtp/smtpauthenticator.h b/src/plugins/messageservices/smtp/smtpauthenticator.h
index 8202437..d402c3c 100644
--- a/src/plugins/messageservices/smtp/smtpauthenticator.h
+++ b/src/plugins/messageservices/smtp/smtpauthenticator.h
@@ -50,8 +50,12 @@
 class SmtpAuthenticator
 {
 public:
-    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+#ifdef USE_ACCOUNTS_QT
+    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, QList<QByteArray> &ssoLogin);
+#else
+    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/smtp/smtpclient.cpp b/src/plugins/messageservices/smtp/smtpclient.cpp
index 1c38e00..c3579f5 100644
--- a/src/plugins/messageservices/smtp/smtpclient.cpp
+++ b/src/plugins/messageservices/smtp/smtpclient.cpp
@@ -100,6 +100,26 @@ static QByteArray localName()
     return "localhost.localdomain";
 }
 
+#ifdef USE_ACCOUNTS_QT
+SmtpClient::SmtpClient(QObject* parent)
+    : QObject(parent)
+    , mailItr(mailList.end())
+    , messageLength(0)
+    , sending(false)
+    , transport(0)
+    , temporaryFile(0)
+    , waitingForBytes(0)
+    , notUsingAuth(false)
+    , authTimeout(0)
+    , ssoSessionManager(0)
+    , loginFailed(false)
+    , sendLogin(false)
+    , accountUpdated(false)
+{
+    connect(QMailStore::instance(), SIGNAL(accountsUpdated(const QMailAccountIdList&)),
+            this, SLOT(accountsUpdated(const QMailAccountIdList&)));
+}
+#else
 SmtpClient::SmtpClient(QObject* parent)
     : QObject(parent)
     , mailItr(mailList.end())
@@ -114,12 +134,17 @@ SmtpClient::SmtpClient(QObject* parent)
     connect(QMailStore::instance(), SIGNAL(accountsUpdated(const QMailAccountIdList&)), 
             this, SLOT(accountsUpdated(const QMailAccountIdList&)));
 }
+#endif
 
 SmtpClient::~SmtpClient()
 {
     delete transport;
     delete temporaryFile;
     delete authTimeout;
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager)
+        ssoSessionManager->deleteSsoIdentity();
+#endif
 }
 
 void SmtpClient::accountsUpdated(const QMailAccountIdList &ids)
@@ -131,6 +156,7 @@ void SmtpClient::accountsUpdated(const QMailAccountIdList &ids)
     bool isEnabled(acc.status() & QMailAccount::Enabled);
     if (!isEnabled)
         return;
+    accountUpdated = true;
     setAccount(account());
 }
 
@@ -143,6 +169,22 @@ void SmtpClient::setAccount(const QMailAccountId &id)
 {
     // Load the current configuration for this account
     config = QMailAccountConfiguration(id);
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoSessionManager) {
+        SmtpConfiguration smtpCfg(config);
+        ssoSessionManager = new SSOSessionManager(this);
+        if (ssoSessionManager->createSsoIdentity(id, "smtp", smtpCfg.smtpAuthentication())) {
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionResponse(QList<QByteArray>))
+                            ,this, SLOT(onSsoSessionResponse(QList<QByteArray>))));
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionError(QString)),this, SLOT(onSsoSessionError(QString))));
+            qMailLog(SMTP) << Q_FUNC_INFO << "SSO identity is found for account id: "<< id;
+        } else {
+            delete ssoSessionManager;
+            qMailLog(SMTP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                           << ", accounts configuration will be used";
+        }
+    }
+#endif
 }
 
 QMailAccountId SmtpClient::account() const
@@ -153,6 +195,9 @@ QMailAccountId SmtpClient::account() const
 void SmtpClient::newConnection()
 {
     qMailLog(SMTP) << "newConnection" << flush;
+#ifdef USE_ACCOUNTS_QT
+    loginFailed = false;
+#endif
     if (sending) {
         operationFailed(QMailServiceAction::Status::ErrConnectionInUse, tr("Cannot send message; transport in use"));
         return;
@@ -164,6 +209,12 @@ void SmtpClient::newConnection()
         return;
     }
 
+    // Load the current configuration for this account
+    // Reload the account configuration whenever a new SMTP
+    // connection is created, in order to ensure the changes
+    // in the account settings are being managed properly.
+    config = QMailAccountConfiguration(config.id());
+
     SmtpConfiguration smtpCfg(config);
     if ( smtpCfg.smtpServer().isEmpty() ) {
         status = Done;
@@ -312,9 +363,7 @@ void SmtpClient::sendCommand(const char *data, int len)
 
     ++outstandingResponses;
 
-    if (len) {
-        qMailLog(SMTP) << "SEND:" << data;
-    }
+    qMailLog(SMTP) << "SEND:" << data;
 }
 
 void SmtpClient::sendCommand(const QString &cmd)
@@ -516,6 +565,31 @@ void SmtpClient::nextAction(const QString &response)
         addressComponent = localAddress.toIPv4Address();
 
         // Find the authentication mode to use
+#ifdef USE_ACCOUNTS_QT
+        if (ssoSessionManager) {
+            // start single signon session
+            status = SignOnSession;
+            nextAction(QString());
+        } else {
+            // Use credentials from accounts db
+            // Find the authentication mode to use
+            ssoLogin.clear();
+            QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities, ssoLogin));
+            if (!authCmd.isEmpty()) {
+                sendCommand(authCmd);
+                status = Authenticating;
+            } else {
+                foreach (QString const& capability, capabilities) {
+                    if (capability.startsWith("AUTH", Qt::CaseInsensitive)) {
+                        notUsingAuth = true;
+                        break;
+                    }
+                }
+                status = Authenticated;
+                nextAction(QString());
+            }
+        }
+#else
         QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities));
         if (!authCmd.isEmpty()) {
             sendCommand(authCmd);
@@ -530,8 +604,30 @@ void SmtpClient::nextAction(const QString &response)
             status = Authenticated;
             nextAction(QString());
         }
+#endif
+        break;
+    }
+#ifdef USE_ACCOUNTS_QT
+    case SignOnSession:
+    {
+        if (loginFailed) {
+            if (ssoSessionManager) {
+                sendLogin = true;
+                ssoSessionManager->recreateSsoIdentity(!accountUpdated);
+            } else
+                operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+        } else {
+            if (!ssoSessionManager->waitForSso()) {
+                QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities, ssoLogin));
+                sendCommand(authCmd);
+                status = Authenticating;
+            } else {
+                sendLogin = true;
+            }
+        }
         break;
     }
+#endif
     case Authenticating:
     {
         if (responseCode == 334) {
@@ -545,8 +641,9 @@ void SmtpClient::nextAction(const QString &response)
                 bufferedResponse.clear();
                 return;
             } else {
-                // No username/password defined
-                operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+                // Challenge response is empty
+                // send a empty response.
+                sendCommand("");
             }
         } else if (responseCode == 235) {
             // We are now authenticated
@@ -555,14 +652,26 @@ void SmtpClient::nextAction(const QString &response)
         } else if (responseCode == 530) {
             operationFailed(QMailServiceAction::Status::ErrConfiguration, response);
         } else {
+#ifdef USE_ACCOUNTS_QT
+            if (!loginFailed) {
+                loginFailed = true;
+                status = SignOnSession;
+                nextAction(QString());
+            } else {
+                operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+            }
+#else
             operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+#endif
         }
-
         // Otherwise, we're authenticated
         break;
     }
     case Authenticated:
     {
+#ifdef USE_ACCOUNTS_QT
+        loginFailed = false;
+#endif
         if (mailItr == mailList.end()) {
             // Nothing to send
             status = Quit;
@@ -816,6 +925,10 @@ void SmtpClient::nextAction(const QString &response)
 void SmtpClient::cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text)
 {
     operationFailed(code, text);
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager)
+        ssoSessionManager->cancel();
+#endif
 }
 
 void SmtpClient::messageProcessed(const QMailMessageId &id)
@@ -970,3 +1083,40 @@ void SmtpClient::stopTransferring()
         status = Sent;
     }
 }
+
+#ifdef USE_ACCOUNTS_QT
+void SmtpClient::removeSsoIdentity(const QMailAccountId &accountId)
+{
+    if (config.id() == accountId) {
+        if (ssoSessionManager) {
+            ssoSessionManager->removeSsoIdentity();
+            delete ssoSessionManager;
+        }
+    }
+}
+
+void SmtpClient::onSsoSessionResponse(const QList<QByteArray> &ssoCredentials)
+{
+    qMailLog(SMTP)  << "Got SSO response";
+    if(!ssoCredentials.isEmpty()) {
+        ssoLogin = ssoCredentials;
+        if (accountUpdated)
+            accountUpdated = false;
+        if (sendLogin) {
+            sendLogin = false;
+            QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities, ssoLogin));
+            sendCommand(authCmd);
+            status = Authenticating;
+        }
+    }
+}
+
+void SmtpClient::onSsoSessionError(const QString &error)
+{
+    // Reset vars
+    loginFailed = false;
+    sendLogin = false;
+    qMailLog(SMTP) <<  "Got SSO error:" << error;
+    operationFailed(QMailServiceAction::Status::ErrLoginFailed, error);
+}
+#endif
diff --git a/src/plugins/messageservices/smtp/smtpclient.h b/src/plugins/messageservices/smtp/smtpclient.h
index 3ad297c..a1dcf47 100644
--- a/src/plugins/messageservices/smtp/smtpclient.h
+++ b/src/plugins/messageservices/smtp/smtpclient.h
@@ -51,6 +51,10 @@
 #include <qmailmessageserver.h>
 #include <qmailtransport.h>
 
+#ifdef USE_ACCOUNTS_QT
+#include <ssosessionmanager.h>
+#endif
+
 class QTemporaryFile;
 
 struct RawEmail
@@ -73,6 +77,10 @@ public:
     void setAccount(const QMailAccountId &accountId);
     QMailAccountId account() const;
 
+#ifdef USE_ACCOUNTS_QT
+    void removeSsoIdentity(const QMailAccountId &accountId);
+#endif
+
     void newConnection();
     void cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text);
 
@@ -97,6 +105,10 @@ protected slots:
 private slots:
     void sendMoreData(qint64);
     void authExpired();
+#ifdef USE_ACCOUNTS_QT
+    void onSsoSessionResponse(const QList<QByteArray> &ssoCredentials);
+    void onSsoSessionError(const QString &error);
+#endif
 
 private:
     void sendCommand(const char *data, int len = -1);
@@ -112,11 +124,19 @@ private:
     void stopTransferring();
 
 private:
+#ifdef USE_ACCOUNTS_QT
+    enum TransferStatus
+    {
+        Init, Helo, Extension, StartTLS, TLS, Connected, SignOnSession,  Authenticating, Authenticated,
+        MetaData, From, Recv, MRcv, PrepareData, Data, Body, Chunk, ChunkSent, Sent, Quit, Done
+    };
+#else
     enum TransferStatus
     {
         Init, Helo, Extension, StartTLS, TLS, Connected, Authenticating, Authenticated,
         MetaData, From, Recv, MRcv, PrepareData, Data, Body, Chunk, ChunkSent, Sent, Quit, Done
     };
+#endif
 
     QMailAccountConfiguration config;
     TransferStatus status;
@@ -149,6 +169,14 @@ private:
     bool notUsingAuth;
 
     QTimer *authTimeout;
+
+#ifdef USE_ACCOUNTS_QT
+    SSOSessionManager* ssoSessionManager;
+    bool loginFailed;
+    bool sendLogin;
+    bool accountUpdated;
+    QList<QByteArray> ssoLogin;
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/smtp/smtpservice.cpp b/src/plugins/messageservices/smtp/smtpservice.cpp
index 5cace7f..8803bf3 100644
--- a/src/plugins/messageservices/smtp/smtpservice.cpp
+++ b/src/plugins/messageservices/smtp/smtpservice.cpp
@@ -253,6 +253,11 @@ void SmtpService::onAccountsUpdated(const QMailAccountIdList &accountIds)
 
 SmtpService::~SmtpService()
 {
+#ifdef USE_ACCOUNTS_QT
+    //If account was deleted, we should remove appropriate signon identity from the signon.db
+    if (!accountId().isValid())
+        _client.removeSsoIdentity(accountId());
+#endif
     delete _sink;
 }
 
diff --git a/src/plugins/ssoauth/password/password.pro b/src/plugins/ssoauth/password/password.pro
new file mode 100644
index 0000000..9964a4e
--- /dev/null
+++ b/src/plugins/ssoauth/password/password.pro
@@ -0,0 +1,27 @@
+TEMPLATE = lib 
+TARGET = passwordplugin
+CONFIG += plugin
+QT = core
+
+equals(QT_MAJOR_VERSION, 4) {
+    target.path += $$QMF_INSTALL_ROOT/lib/qmf/plugins/ssoauth
+    LIBS += -lqmfclient
+}
+equals(QT_MAJOR_VERSION, 5) {
+    target.path += $$QMF_INSTALL_ROOT/lib/qmf/plugins5/ssoauth
+    LIBS += -lqmfclient5
+}
+
+DEPENDPATH += .
+
+INCLUDEPATH += . ../../../libraries/qmfclient \
+               ../../../libraries/qmfclient/support
+
+LIBS += -L../../../libraries/qmfclient/build
+macx:LIBS += -F../../../libraries/qmfclient/build
+
+HEADERS += passwordplugin.h
+
+SOURCES += passwordplugin.cpp
+
+include(../../../../common.pri)
diff --git a/src/plugins/ssoauth/password/passwordplugin.cpp b/src/plugins/ssoauth/password/passwordplugin.cpp
new file mode 100644
index 0000000..f7f2a76
--- /dev/null
+++ b/src/plugins/ssoauth/password/passwordplugin.cpp
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valrio Valrio <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "passwordplugin.h"
+#include "qmailnamespace.h"
+
+// From Qt Messaging Framework IMAP plugin
+// Ensure a string is quoted, if required for IMAP transmission
+// As per IMAP4 rfc 2060 section 4.2
+QString quoteIMAPString(const QString& input)
+{
+    // We can't easily catch controls other than those caught by \\s...
+    QRegExp atomSpecials("[\\(\\)\\{\\s\\*%\\\\\"\\]]");
+
+    // The empty string must be quoted
+    if (input.isEmpty())
+        return QString("\"\"");
+
+    if (atomSpecials.indexIn(input) == -1)
+        return input;
+
+    // We need to quote this string because it is not an atom
+    QString result(input);
+
+    QString::iterator begin = result.begin(), it = begin;
+    while (it != result.end()) {
+        // We need to escape any characters specially treated in quotes
+        if ((*it) == '\\' || (*it) == '"') {
+            int pos = (it - begin);
+            result.insert(pos, '\\');
+            it = result.begin() + (pos + 1);
+        }
+        ++it;
+    }
+
+    return QMail::quoteString(result);
+}
+
+QByteArray quoteIMAPString(const QByteArray& input)
+{
+    return quoteIMAPString(QString::fromLatin1(input)).toLatin1();
+}
+
+SSOPasswordPlugin::SSOPasswordPlugin(QObject *parent)
+    : SSOAuthService(parent)
+{
+}
+
+SSOPasswordPlugin::~SSOPasswordPlugin()
+{
+}
+
+QList<QByteArray> SSOPasswordPlugin::getIMAPAuthentication(const QString &password,
+                                                    const QString &username, int serviceAuthentication) const
+{
+    if (serviceAuthentication == QMail::PlainMechanism) {
+        QByteArray user(username.toLatin1());
+        QByteArray pass(password.toLatin1());
+        return QList<QByteArray>() << QByteArray("AUTHENTICATE PLAIN ") + QByteArray(user + '\0' + user + '\0' + pass).toBase64();
+    } else {
+        return QList<QByteArray>() << QByteArray("LOGIN") + ' ' + quoteIMAPString(username.toLatin1())
+                                   + ' ' + quoteIMAPString(password.toLatin1());
+    }
+}
+
+QList<QByteArray> SSOPasswordPlugin::getPOPAuthentication(const QString &password,
+                                                   const QString &username, int serviceAuthentication) const
+{
+    Q_UNUSED(serviceAuthentication);
+    QList<QByteArray> result;
+
+    result.append(QByteArray("USER ") + username.toLatin1());
+    result.append(QByteArray("PASS ") + password.toLatin1());
+
+    return result;
+}
+
+QList<QByteArray> SSOPasswordPlugin::getSMTPAuthentication(const QString &password,
+                                                    const QString &username, int serviceAuthentication) const
+{
+    QList<QByteArray> result;
+    QByteArray user(username.toLatin1());
+    QByteArray pass(password.toLatin1());
+
+    if (serviceAuthentication == QMail::LoginMechanism) {
+        result.append(QByteArray("AUTH LOGIN"));
+        result.append(QByteArray(user));
+        result.append(QByteArray(pass));
+    } else if (serviceAuthentication == QMail::PlainMechanism) {
+        result.append(QByteArray("AUTH PLAIN"));
+        result.append(QByteArray(user + '\0' + user + '\0' + pass));
+    }
+    return result;
+}
+
+SSOAuthService* SSOPasswordPlugin::createService()
+{
+    return this;
+}
+
+QString SSOPasswordPlugin::key() const
+{
+    return "password";
+}
+QList<QByteArray> SSOPasswordPlugin::authentication(const SignOn::SessionData &sessionData,
+                                                const QString &serviceType, const QString &userName, int serviceAuthentication) const
+{
+    QString password = sessionData.Secret();
+    QString username = sessionData.UserName();
+
+    if (username.isEmpty())
+        username = userName;
+
+    if (serviceType == "imap4") {
+        return getIMAPAuthentication(password, username, serviceAuthentication);
+    } else if (serviceType == "pop3") {
+        return getPOPAuthentication(password, username, serviceAuthentication);
+    } else if (serviceType == "smtp") {
+        return getSMTPAuthentication(password, username, serviceAuthentication);
+    } else {
+        return QList<QByteArray>();
+    }
+}
+
+SignOn::SessionData SSOPasswordPlugin::sessionData(const QString &accountProvider,  QVariantMap authParameters,
+                                                   bool setUiPolicy) const
+{
+    Q_UNUSED(accountProvider);
+    Q_UNUSED(authParameters);
+
+    SignOn::SessionData data;
+    if (setUiPolicy)
+        data.setUiPolicy(SignOn::RequestPasswordPolicy);
+    return data;
+}
+
+#if (QT_VERSION < QT_VERSION_CHECK(5, 0, 0))
+Q_EXPORT_PLUGIN2(password,SSOPasswordPlugin)
+#endif
diff --git a/src/plugins/ssoauth/password/passwordplugin.h b/src/plugins/ssoauth/password/passwordplugin.h
new file mode 100644
index 0000000..bdf7281
--- /dev/null
+++ b/src/plugins/ssoauth/password/passwordplugin.h
@@ -0,0 +1,74 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valrio Valrio <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef PASSWORDPLUGIN_H
+#define PASSWORDPLUGIN_H
+
+#include "ssoauthplugin.h"
+#include <QtPlugin>
+#include <QVariantMap>
+#include <SignOn/SessionData>
+
+class SSOPasswordPlugin : public SSOAuthService
+{
+    Q_OBJECT
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.SSOPasswordPluginHandlerFactoryInterface")
+#endif
+
+public:
+    SSOPasswordPlugin( QObject *parent = 0 );
+    ~SSOPasswordPlugin();
+
+    virtual QString key() const;
+    virtual QList<QByteArray> authentication(const SignOn::SessionData &sessionData,
+                                         const QString &serviceType, const QString &userName, int serviceAuthentication) const;
+    virtual SignOn::SessionData sessionData(const QString &accountProvider, QVariantMap authParameters,
+                                            bool setUiPolicy) const;
+    virtual SSOAuthService* createService();
+
+private:
+    QList<QByteArray> getIMAPAuthentication(const QString &password, const QString &username, int serviceAuthentication) const;
+    QList<QByteArray> getPOPAuthentication(const QString &password, const QString &username, int serviceAuthentication) const;
+    QList<QByteArray> getSMTPAuthentication(const QString &password, const QString &username, int serviceAuthentication) const;
+};
+
+#endif // PASSWORDPLUGIN_H
diff --git a/tests/tst_qmailstore/tst_qmailstore.cpp b/tests/tst_qmailstore/tst_qmailstore.cpp
index f0b8a78..17ddf53 100644
--- a/tests/tst_qmailstore/tst_qmailstore.cpp
+++ b/tests/tst_qmailstore/tst_qmailstore.cpp
@@ -118,6 +118,9 @@ void tst_QMailStore::cleanupTestCase()
 
 void tst_QMailStore::addAccount()
 {
+
+    QSignalSpy spyAccountAdded(QMailStore::instance(), SIGNAL(accountsAdded(QMailAccountIdList)));
+
     QMailAccount account1;
     account1.setName("Account 1");
     account1.setFromAddress(QMailAddress("Account 1", "account1@example.org"));
@@ -155,6 +158,9 @@ void tst_QMailStore::addAccount()
     QCOMPARE(QMailStore::instance()->countAccounts(), 1);
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
 
+    // Verify that the addAccount signal is emitted only once
+    QCOMPARE(spyAccountAdded.count(), 1);
+
     // Verify that retrieval yields matching result
     QMailAccount account2(account1.id());
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
@@ -1224,6 +1230,8 @@ void tst_QMailStore::updateMessages()
 
 void tst_QMailStore::removeAccount()
 {
+    QSignalSpy spyAccountRemoved(QMailStore::instance(), SIGNAL(accountsRemoved(QMailAccountIdList)));
+
     QMailAccount account1;
     account1.setName("Account 1");
     account1.setFromAddress(QMailAddress("Account 1", "account1@example.org"));
@@ -1279,6 +1287,9 @@ void tst_QMailStore::removeAccount()
     QCOMPARE(QMailStore::instance()->countAccounts(), 0);
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
 
+    // Verify that the removeAccount signal is emitted only once
+    QCOMPARE(spyAccountRemoved.count(), 1);
+
     // Verify that retrieval yields invalid result
     QMailAccount account3(account1.id());
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::InvalidId);
-- 
1.7.9.5

